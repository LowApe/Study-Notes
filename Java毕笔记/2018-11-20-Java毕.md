finally<br>
当用户在访问类似数据库的操作,数据库连接资源有限,当使用完成后需要释放资源,就是用到finally
```java
1. 连接数据库
2. 数据库操作  // 异常的多发地
3. 关闭数据库
```
// 记住一点: catch 是用于处理异常.如果没有 catch 就代表异常没有被处理过,如果该异常时检测异常,那么就必须声明
try{

}catch{

}finally


try{

}finally{
    //关资源
}

> 一种情况finally 不会执行-那就是System.exit(0);

-----
当父类方法抛出一个拥有子父级关系的异常,子类继承了父类并复写了父类的方法,子类不能抛出最新的异常,只能抛出父类的异常.<br>
如果一个类方法使用了父类方法并 try catch 抛出异常为父类的,子类传入这个方法时如果时新异常就会报错

> 1. 子类再覆盖父类时,如果父类的方法抛出异常,那么子类的覆盖方法,只能抛出父类的异常或者该异常的子类
2. 如果父类方法抛出多个异常,那么子类在覆盖该方法时,只能抛出父类异常的子集
3. 如果父类或者接口的方法中没有异常抛出,那么子类再覆盖方法时也不可以抛出异常.
    **如果子类方法发生了异常,就必须 try catch 绝对不能抛**


> 当开发过程中,如果出现问题,就不需要if 判断,尽量使流程代码,与问题处理分开来。好的方式就是自定义异常,配合继承Exception 或者 RuntimeException (两者区别使 后者 不需要throws and try catch 直接停止 )


----
总结 ：<br>
1. 异常是对问题的描述. 将问题进行对象的封装.
2. 异常体系:<br>
    Throwable
        |--Error
        |--Exception
            |--RuntimeException
3. 异常体系的特点:异常体系中所有类以及建立的对象都具备可抛性.也就是说可以被 throw 和 throws 关键字所操作。

4. throw 和 throws 的用法:
throw 定义在函数内,用于抛出异常对象<br>
throws 定义在函数上,用于抛出异常类,可以抛出多个用逗号隔开。

5. 当函数内有throw 抛出异常对象,并未进行try 处理,必须在函数上声明,否则编译失败。**注意:RuntimeException 除外,也就是说,函数内如果抛出的RuntimeException 函数不用声明**

6. 如果函数声明了异常,调用者需要进行处理,处理方法可以 throws 可以try

7. 异常有两种:
    1. 编译时被检测异常-该异常在编译时,如果没有处理(无throw 和 try 编译失败)
    2. 运行时异常(编译时不检查)


-----
异常的好处:<br>

1. 将问题进行分装
2. 正常代码与问题处理代码分离

----
异常的处理原则:<br>
1. 处理方式有两种:try 或者 throws
2. 调用抛出异常,抛出1几个,catch 几个
3. 多个catch ,父类的catch放在最下面
4. 如果异常处理不了,但并不属于该功能出现的异常。可以将异常转换后,在抛出和该功能相关的异常。

----

异常的注意事项:
在子父类覆盖时:
1. 子类抛出的异常必须是父类的异常的子类或者子集。
2. 如果父类或者接口没有异常抛出时,子类覆盖出现异常,只能try不能抛
