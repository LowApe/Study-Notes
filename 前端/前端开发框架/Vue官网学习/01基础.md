

# 安装

使用 Vue 前安装

- Google 游览器安装 [Vue Devtools](https://github.com/vuejs/vue-devtools#vue-devtools) 方便调试和查看
- IDE 编辑器 VS Code 或者 WebStorm
- Node.js 8.9+，npm



使用Vue方式

## 1 `<script>`引入

- 文件引用 下载[vue.js](https://cn.vuejs.org/js/vue.js) 或[vue.min.js](https://cn.vuejs.org/js/vue.min.js)生产版本
- CDN 引用

示例

```html
// 文件引用
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="vue.js"></script>
</head>
<body>
    
</body>
</html>

// CDN
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 文件引用方式 -->
    <!-- <script src="vue.js"></script> -->
    <!-- CDN形式引用 -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
</head>
<body>
    <div id="app">
        {{message}}
    </div>
    <script>
        var app = new Vue({
            el: '#app',
            data:{
                message: 'Hello Vue!'
            }
        })
    </script>
</body>
</html>
```

## 2 NPM

在用 Vue 构建应用时推荐使用 npm 安装。NPM 能很好地和诸如 webpack 或 Browserify **模块打包器配合使用**。同时 Vue 也提供配套工具开发 **单文件组件**

```shell
npm install vue
```

> 单独使用该命令会生成包含 vue 文件夹在 `node_modules`

## 3 命令行工具(CLI)

```shell
# 使用 cli 创建 vue 项目
$ vue create xxxx
```

## 4 不同构建版本的解释

上面 `npm install vue` 的下载到`node_modules(npm 局部使用的依赖包文件夹)`对应vue文件 ，项目结构如下

![image.png](http://ww1.sinaimg.cn/mw690/006rAlqhgy1gkyc91l7vxj30b208w0sz.jpg)

`dist`目录下回找到不同的 Vue.js 构建版本

|                    | UMD                | CommonJS               | ES Module（基于构建工具） | ES      Module（直接游览器） |
| ------------------ | ------------------ | ---------------------- | ------------------------- | ---------------------------- |
| 完整版             | vue.js             | vue.common.js          | vue.esm.js                | vue.esm.browser.js           |
| 只包含运行时       | vue.runtime.js     | vue.runtime..common.js | vue.runtime.esm.js        |                              |
| 完整版(生产)       | vue.min.js         |                        |                           | vue.esm.brower.min.js        |
| 只包含运行时(生产) | vue.runtime.min.js |                        |                           |                              |

> 上述文件根据不同环境，是否使用编译器，编写的语法不通，通常需要编译器的可以写类似 React JSX的模版语言，这时一般是完整版和运行时加编译器的文件环境。剩下的内容打包工具之类的，目前还不怎么了理解，后期在看看

# 介绍

所谓的响应式，数据变化，界面也会重新渲染数据部分，示例是修改控制台变量，界面也会修改.

指令带有前缀 `v-`，以表示它们是 Vue 提供的特殊 attribute,

- `v-model`指令，轻松实现表单输入和应用状态之间的双向绑定
- `v-for` 循环指令
- `v-bind` 配合`v-for`将循环输出到每一个组件

# Vue 实例

所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象(一些根实例特有的选项除外)

## 数据与方法

> 放一个 Vue 实例被创建时，它将 `data` 对象中的所有 `property` 加入到 Vue 的**响应式系统**，当这些 `property` 的值发生变化时，视图将产生响应，即匹配更新为新的值

```js
// 我们的数据对象
var data = { a : 1}

// 将对象被加入到一个 Vue 实例中
var vm = new Vue({
    data: data
})

// 获得这个实例上的 property
// 返回源数据中对应的字段
vm.a == data.a // => true

// 设置 property 也会影响到原始数据
vm.a = 2
data.a // => 2

// ...反之亦然
data.a = 3
vm.a // => 3
```

> ⚠️注意：只有当实例被创建时就已经存在于 `data`中的 `property`才是响应式的。如果你知道你会在晚些时候需要一个 `property`，但是一开始它为空或不存在，那么你仅需要设置一些初始值。

除了数据 property，Vue 实例还暴漏了一些有用的实例 `property` 与方法。它们都有前缀 `$`,以便与用户定义的 `property`区分开来。例如：

```js
var data = { a:1}
var vm = new Vue({
    el:'#example',
    data: data
})

vm.$data === data // =>data
vm.$el === document.getElementById('example') // => true

// $watch 是一个实例方法
vm.$watch('a',function(newValue,ol){
    // 这个回调将在 vm.a 改变后调用
})
```

## 实例生命周期钩子

> 每个 Vue 实例在被创建时都要经过一系列的初始化过程,需要设置数据监听、编译模版、将实例挂载到 DOM 并在数据变化时更新 DOM 等。
>
> **在这个过程中会运行一些叫做生命周期钩子的函数，提供给用户在不同阶段添加自己代码的机会**

比如 `created`钩子可以用来在**一个实例被创建之**后执行代码：

```js
new Vue({
    data:{
        a: 1
    },
    created: function(){
        // this 指向 vm 实例
        console.log('a is:' + this.a)
    }
})

// => "a is: 1"
```

> **生命周期钩子的 `this`上下文指向调用它的 Vue 实例**
>
> ⚠️注意：不要在选项 `property` 或回调上使用 **箭头函数**，比如 
>
> - `created:()=> console.log(this.a)`
> - `vm.$watch('a',newValue => this.myMethod())`
>
> 因为箭头函数并没有 `this`，`this`会作为变量一直向上级词法作用域查找，直至找到为止，经常导致错误：`Uncaught TypeError: Cannot read property of undefined`

## 生命周期图示

下图展示里实例的生命周期。

![image.png](http://ww1.sinaimg.cn/mw690/006rAlqhgy1glcuf5spqfj30xc2cftdz.jpg)

> 左侧红色圆框表示生命周期钩子

# 模版语法

在底层的实现上，Vue 将模版编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少

> 如果你熟悉虚拟 DOM 喜欢 JavaSCript 的原始力量，你也不可以不用模版，直接写渲染(render) 函数,使用可选的 JSX 语法

## 插值

**文本**

> 数据绑定最常见的形式就是使用 "Mustache" 语法(双大括号)

```HTML
<span>Message:{{ msg }}</span>
```

绑定的数据对象上 `msg` property 发生了改变，插值处的内容都会更新。通过使用**v-once**指令，也能执行一次性地插值，当数据改变时，插值处的内容不会更新。

```html
<span v-once>这个将不会改变{{ msg }}</span>
```

**原始 HTML**

双大括号会将数据解释为普通文本，而非 HTML 带啊吗。为了输出HTML使用

**Attribute**

Mustache 语法不能作用在 HTML attribute 上，遇到下面这种应该使用 `v-bind`指令：

```html
<div v-bind:id="dynamicID"></div>
```

**使用 JavaScirpt 表达式**

对于所有的数据绑定，Vue.js 都提供了完全的 JavaScirpt 表达式支持

```html
{{ number + 1}}
{{ ok ? 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}
<div v-bind:id="'list-' + id"></div>
```

> ⚠️注意：这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，**每个绑定都只能包含单个表达式**，所以下面的例子都不会生效

```html
<!-- 这是语句，不是表达式 -->
{{ var a = 1}}

<!-- 流控制也不会生效，请使用三元表达式 -->
{{ if (ok) { return message } }}
```

> 🤔 不太清楚：模版表达式都被放在沙盒中，只能访问全局变量的一个白名单，如`Math`盒`Date`你不应该在模版表达式中视图访问用户定义的全局变量

## 指令

> 指令带有 `v-`前缀的特殊 attribute。**attribute 的值预期是单个 JavaScript 表达式**

### 参数

**一些指令能够接受一个"参数"，在指令名称之后以冒号表示。**

```html
<a v-bind:href="url">..</a>
```

在这里`href` 是参数，**告知 `v-bind`指令将元素的 `href` attribute 与表达式 `url` 的值绑定**

### 动态参数

可以使用方括号扩起来的 JavaScript 表达式作为一个指令的参数：

```html
<a v-bind:[attributeName]="url"> ... </a>
```

这里 `attributeName` 作为 JS 表达式进行动态求值，求得得值将会作为最终的参数来使用，例如有一个 data property `attributeName`，期值为 `href`，那么这个绑定将等价于 `v-bind:href`.

> 动态参数约束：
>
> - 使用没有空格和引号的表达式
> - 或用计算属性代替复杂表达式
> - 避免使用大写字符来命名，因为会把`[]` b变量全部强制专为小写

### 修饰符

修饰符以`.`指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent`修饰符告诉`v-on` 指令对于触发的事件调用`event.preventDefault()`:

```html
<form v-on:submit.prevent="onSubmit">
    
</form>
```

## 缩写

`v-`前缀作为一种视觉提示，用来识别模版中 Vue 指定的 `attribute`.d当你在使用 Vue.js 为现有标签添加动态行为时，`v-`前缀很有帮助🤔

### v-bind 缩写

```html
<!-- 完整语法 -->
<a v-bind:href="url">...</a>

<!-- 缩写 -->
<a :href="url">...</a>

<!-- 动态缩写（2.6.0） -->
<a :[key]="url"> ... </a>
```

### v-on 缩写

```html
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>

<!-- 动态参数的缩写(2.6.0+) -->
<a @[event]="doSomething">...</a>
```

# 计算属性和侦听器 🌟

## 计算属性

模版的设计用于简单运算的，如果对于复杂逻辑，你都应当使用 **计算属性**

```html
<div id="example">
    <p>
        Original message:"{{messagge}}"
    </p>
    <p>
        Computed reversed message:"{{reveredMessage}}"
    </p>
</div>
```

```js
var vm = new Vue({
    el:'@example',
    data:{
        message: 'Hello'
    },
    computed:{
        // 计算属性的 getter
        reversedMessage: function (){
            return this.message.split('').reverse().join('')
        }
    }
})
```

> 你可以像绑定普通 property 一样在模版中绑定计算属性。Vue 知道 `vm.reversedMessage` 依赖于 `vm.message`,因此当 `vm.message` 发生改变时，所有依赖 `vm.reversedMessage`的绑定也会更新

### 计算属性缓存 vs 方法 

如果将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。**不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值**

- 特例：`Date.now（）`不是响应式依赖

计算属性是有缓存的🤔？？



### 计算属性 vs 监听属性

Vue 提供一种更通用的方式来观察和响应 Vue 实例上的数据变动：**监听属性**

当你有一些数据需要随着其他数据变动而变动时，你很容易滥用 `watch`

```html
<div id="demo">
    {{ fullName }}
</div>
```

```Js
var vm = new Vue({
    el:'#demo',
    data: {
        firstName: 'Foo',
        lastName: 'Bar',
        fullName: 'Foo Bar',
    },
    watch:{
        firstName: function (val){
            this.fullName = val + ' ' + this.lastName
        },
        lastName: function (val){
            this.fullName = this.firstName + ' ' + val
        }
    }
})
```

**上面代码是命令式且重复的**将它与计算属性的版本进行比较：

```JS
var vm = new Vue({
    el: '#demo',
    data: {
        firstName: 'Foo',
        lastName: 'Bar'
    },
    computed: {
        fullName:function(){
           return this.firstName + ' ' + this.lastName
        }
    }
})
```

> 。。。。不明白这个例子，watch 只能监听字段的话，那坑定用计算属性函数啊...

### 计算属性的 setter

计算属性默认只有 getter, 不过在需要时你也可以提供一个 setter:

```JS
// ...
computed: {
    fullName: {
        // getter
        get: function (){
            return this.firstName + ' ' + this.lastName
        },
        // setter
        set: function (newValue){
            var name s = newValue.split(' ')
            this.firstName = names[0]
            this.lastName = names[names.length -1]
        }
    }
}
```

> 现在运行 `vm.fullName = 'John Doe'`时，setter 会被调用， `vm.firstName` 和 `vm.lastName`也会相应地更新

## 监听器

有时也需要一个自定义的监听器。**当需要在数据变化时执行异步或开销较大的操作时**，这个方法是最有用的。例如

```html
<div id = "watch-example">
    <p>
        Ask a yes/no question:
        <input v-model="question">
    </p>
    <p>
        {{ answer }}
    </p>
</div>
```

```js
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
var watchExampleVM = new Vue({
    el:'#watch-example',
    data:{
        question: '',
        answer:'I cannot give you an answer until you ask...'
    }
    watch:{
    	// 如果 question 发生改变，这个函数就会运行
    	question: function(newQuestion,oldQuestion){
    		this.answer = 'Waiting for you to stop typing...'
    		this.debouncedGetAnswer()
		}
	},
    created: function(){
        // loadsh 限制访问频率
        this.debouncedGetAnswer = _.debounce(this.getAnswer, 5000)
    },
    methods:{
        getAnswer: function () {
            // 如果没有 ? 这回答提示
            if(this.question.indexOf('?') === -1){
                this.answer = 'Questions usually contain a question'
                reutrn
            }
            this.answer = 'Thinking'
            var vm = this
            // 请求结果
            axios.get('https://yesno.wtf/apo')
           		.then(function (response){
                	vm.answer = _.capitalize(response.data.answer)  
            	})
            	.catch(function (error) {
                	vm.answer = 'Error! Could not reach the API.' + error
            	})
        }
    }
});
```

> 这个实例中，**使用 `watch` 选项允许我们执行异步操作(访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。**这些都是计算属性无法做到的

# Class 与 Style 绑定

操作元素的 class 列表和内联样式是数据绑定的一个常见需求。



## 绑定 HTML Class

### 对象语法

我们可以传个 `v-bind:class` 一个对象，以动态地切换 class:

```html
<div v-bind:class="{ active: isActive }" >
    
</div>
```

上面的依法表示`active`这个 class 存在与否将取决于数据 `property` isActive 的 布尔值



**可以在对象中传入更多字段动态切换多个 class 。此外，v-bind:class 指令也可以与普通的 class attribute 共存。** 

```html
<div class = "static"
     v-bind:class="{ active: isActive ,'text-danger': hasError}">
    
</div>
```

和如下 data：

```js
data: {
    isActive: true,
    hasError: false
}
```

结果渲染为：

```html
<div class="static active">
    
</div>
```

当 `isActove`或者 `hasError`变化时，class 列表将相应地更新。例如，如果 `hasError`的值为 `true`,class 列表将变为 "static active text-danger"

**绑定的数据对象不必内联定义在模版里：**

```html
<div v-bind:class ="classObject">
    
</div>
```

```js
data: {
    classObject: {
        active: true,
        'text-danger':false
    }
}
```

**我们也可以在这里绑定一个返回对象的计算属性**。这是一个常用且强大的模式：

```html
<div v-bind:class="classObject">
    
</div>
<script>
	data:{
        isActive:true,
        error: null
    },
    computed: {
        return {
            active: this.isActive && !this.error,
            'text-danger':this.error && this.error.type === 'fatal'
        }
    }
</script>
```

### 数组语法

