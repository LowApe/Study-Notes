

# 安装

使用 Vue 前安装

- Google 游览器安装 [Vue Devtools](https://github.com/vuejs/vue-devtools#vue-devtools) 方便调试和查看
- IDE 编辑器 VS Code 或者 WebStorm
- Node.js 8.9+，npm



使用Vue方式

## 1 `<script>`引入

- 文件引用 下载[vue.js](https://cn.vuejs.org/js/vue.js) 或[vue.min.js](https://cn.vuejs.org/js/vue.min.js)生产版本
- CDN 引用

示例

```html
// 文件引用
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="vue.js"></script>
</head>
<body>
    
</body>
</html>

// CDN
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- 文件引用方式 -->
    <!-- <script src="vue.js"></script> -->
    <!-- CDN形式引用 -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
</head>
<body>
    <div id="app">
        {{message}}
    </div>
    <script>
        var app = new Vue({
            el: '#app',
            data:{
                message: 'Hello Vue!'
            }
        })
    </script>
</body>
</html>
```

## 2 NPM

在用 Vue 构建应用时推荐使用 npm 安装。NPM 能很好地和诸如 webpack 或 Browserify **模块打包器配合使用**。同时 Vue 也提供配套工具开发 **单文件组件**

```shell
npm install vue
```

> 单独使用该命令会生成包含 vue 文件夹在 `node_modules`

## 3 命令行工具(CLI)

```shell
# 使用 cli 创建 vue 项目
$ vue create xxxx
```

## 4 不同构建版本的解释

上面 `npm install vue` 的下载到`node_modules(npm 局部使用的依赖包文件夹)`对应vue文件 ，项目结构如下

![image.png](http://ww1.sinaimg.cn/mw690/006rAlqhgy1gkyc91l7vxj30b208w0sz.jpg)

`dist`目录下回找到不同的 Vue.js 构建版本

|                    | UMD                | CommonJS               | ES Module（基于构建工具） | ES      Module（直接游览器） |
| ------------------ | ------------------ | ---------------------- | ------------------------- | ---------------------------- |
| 完整版             | vue.js             | vue.common.js          | vue.esm.js                | vue.esm.browser.js           |
| 只包含运行时       | vue.runtime.js     | vue.runtime..common.js | vue.runtime.esm.js        |                              |
| 完整版(生产)       | vue.min.js         |                        |                           | vue.esm.brower.min.js        |
| 只包含运行时(生产) | vue.runtime.min.js |                        |                           |                              |

> 上述文件根据不同环境，是否使用编译器，编写的语法不通，通常需要编译器的可以写类似 React JSX的模版语言，这时一般是完整版和运行时加编译器的文件环境。剩下的内容打包工具之类的，目前还不怎么了理解，后期在看看

# 介绍

所谓的响应式，数据变化，界面也会重新渲染数据部分，示例是修改控制台变量，界面也会修改.

指令带有前缀 `v-`，以表示它们是 Vue 提供的特殊 attribute,

- `v-model`指令，轻松实现表单输入和应用状态之间的双向绑定
- `v-for` 循环指令
- `v-bind` 配合`v-for`将循环输出到每一个组件

# Vue 实例

所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象(一些根实例特有的选项除外)

## 数据与方法

> 放一个 Vue 实例被创建时，它将 `data` 对象中的所有 `property` 加入到 Vue 的**响应式系统**，当这些 `property` 的值发生变化时，视图将产生响应，即匹配更新为新的值

```js
// 我们的数据对象
var data = { a : 1}

// 将对象被加入到一个 Vue 实例中
var vm = new Vue({
    data: data
})

// 获得这个实例上的 property
// 返回源数据中对应的字段
vm.a == data.a // => true

// 设置 property 也会影响到原始数据
vm.a = 2
data.a // => 2

// ...反之亦然
data.a = 3
vm.a // => 3
```

> ⚠️注意：只有当实例被创建时就已经存在于 `data`中的 `property`才是响应式的。如果你知道你会在晚些时候需要一个 `property`，但是一开始它为空或不存在，那么你仅需要设置一些初始值。

除了数据 property，Vue 实例还暴漏了一些有用的实例 `property` 与方法。它们都有前缀 `$`,以便与用户定义的 `property`区分开来。例如：

```js
var data = { a:1}
var vm = new Vue({
    el:'#example',
    data: data
})

vm.$data === data // =>data
vm.$el === document.getElementById('example') // => true

// $watch 是一个实例方法
vm.$watch('a',function(newValue,ol){
    // 这个回调将在 vm.a 改变后调用
})
```

## 实例生命周期钩子

> 每个 Vue 实例在被创建时都要经过一系列的初始化过程,需要设置数据监听、编译模版、将实例挂载到 DOM 并在数据变化时更新 DOM 等。
>
> **在这个过程中会运行一些叫做生命周期钩子的函数，提供给用户在不同阶段添加自己代码的机会**

比如 `created`钩子可以用来在**一个实例被创建之**后执行代码：

```js
new Vue({
    data:{
        a: 1
    },
    created: function(){
        // this 指向 vm 实例
        console.log('a is:' + this.a)
    }
})

// => "a is: 1"
```

> **生命周期钩子的 `this`上下文指向调用它的 Vue 实例**
>
> ⚠️注意：不要在选项 `property` 或回调上使用 **箭头函数**，比如 
>
> - `created:()=> console.log(this.a)`
> - `vm.$watch('a',newValue => this.myMethod())`
>
> 因为箭头函数并没有 `this`，`this`会作为变量一直向上级词法作用域查找，直至找到为止，经常导致错误：`Uncaught TypeError: Cannot read property of undefined`

## 生命周期图示

下图展示里实例的生命周期。

![image.png](http://ww1.sinaimg.cn/mw690/006rAlqhgy1glcuf5spqfj30xc2cftdz.jpg)

> 左侧红色圆框表示生命周期钩子

# 模版语法

在底层的实现上，Vue 将模版编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少

> 如果你熟悉虚拟 DOM 喜欢 JavaSCript 的原始力量，你也不可以不用模版，直接写渲染(render) 函数,使用可选的 JSX 语法

## 插值

**文本**

> 数据绑定最常见的形式就是使用 "Mustache" 语法(双大括号)

```HTML
<span>Message:{{ msg }}</span>
```

绑定的数据对象上 `msg` property 发生了改变，插值处的内容都会更新。通过使用**v-once**指令，也能执行一次性地插值，当数据改变时，插值处的内容不会更新。

```html
<span v-once>这个将不会改变{{ msg }}</span>
```

**原始 HTML**

双大括号会将数据解释为普通文本，而非 HTML 带啊吗。为了输出HTML使用

**Attribute**

Mustache 语法不能作用在 HTML attribute 上，遇到下面这种应该使用 `v-bind`指令：

```html
<div v-bind:id="dynamicID"></div>
```

**使用 JavaScirpt 表达式**

对于所有的数据绑定，Vue.js 都提供了完全的 JavaScirpt 表达式支持

```html
{{ number + 1}}
{{ ok ? 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}
<div v-bind:id="'list-' + id"></div>
```

> ⚠️注意：这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，**每个绑定都只能包含单个表达式**，所以下面的例子都不会生效

```html
<!-- 这是语句，不是表达式 -->
{{ var a = 1}}

<!-- 流控制也不会生效，请使用三元表达式 -->
{{ if (ok) { return message } }}
```

> 🤔 不太清楚：模版表达式都被放在沙盒中，只能访问全局变量的一个白名单，如`Math`盒`Date`你不应该在模版表达式中视图访问用户定义的全局变量

## 指令

> 指令带有 `v-`前缀的特殊 attribute。**attribute 的值预期是单个 JavaScript 表达式**

### 参数

**一些指令能够接受一个"参数"，在指令名称之后以冒号表示。**

```html
<a v-bind:href="url">..</a>
```

在这里`href` 是参数，**告知 `v-bind`指令将元素的 `href` attribute 与表达式 `url` 的值绑定**

### 动态参数

可以使用方括号扩起来的 JavaScript 表达式作为一个指令的参数：

```html
<a v-bind:[attributeName]="url"> ... </a>
```

这里 `attributeName` 作为 JS 表达式进行动态求值，求得得值将会作为最终的参数来使用，例如有一个 data property `attributeName`，期值为 `href`，那么这个绑定将等价于 `v-bind:href`.

> 动态参数约束：
>
> - 使用没有空格和引号的表达式
> - 或用计算属性代替复杂表达式
> - 避免使用大写字符来命名，因为会把`[]` b变量全部强制专为小写

### 修饰符

修饰符以`.`指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent`修饰符告诉`v-on` 指令对于触发的事件调用`event.preventDefault()`:

```html
<form v-on:submit.prevent="onSubmit">
    
</form>
```

## 缩写

`v-`前缀作为一种视觉提示，用来识别模版中 Vue 指定的 `attribute`.d当你在使用 Vue.js 为现有标签添加动态行为时，`v-`前缀很有帮助🤔

### v-bind 缩写

```html
<!-- 完整语法 -->
<a v-bind:href="url">...</a>

<!-- 缩写 -->
<a :href="url">...</a>

<!-- 动态缩写（2.6.0） -->
<a :[key]="url"> ... </a>
```

### v-on 缩写

```html
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>

<!-- 动态参数的缩写(2.6.0+) -->
<a @[event]="doSomething">...</a>
```

# 计算属性和侦听器 🌟

## 计算属性

模版的设计用于简单运算的，如果对于复杂逻辑，你都应当使用 **计算属性**

```html
<div id="example">
    <p>
        Original message:"{{messagge}}"
    </p>
    <p>
        Computed reversed message:"{{reveredMessage}}"
    </p>
</div>
```

```js
var vm = new Vue({
    el:'@example',
    data:{
        message: 'Hello'
    },
    computed:{
        // 计算属性的 getter
        reversedMessage: function (){
            return this.message.split('').reverse().join('')
        }
    }
})
```

> 你可以像绑定普通 property 一样在模版中绑定计算属性。Vue 知道 `vm.reversedMessage` 依赖于 `vm.message`,因此当 `vm.message` 发生改变时，所有依赖 `vm.reversedMessage`的绑定也会更新

### 计算属性缓存 vs 方法 

如果将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。**不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值**

- 特例：`Date.now（）`不是响应式依赖

计算属性是有缓存的🤔？？



### 计算属性 vs 监听属性

Vue 提供一种更通用的方式来观察和响应 Vue 实例上的数据变动：**监听属性**

当你有一些数据需要随着其他数据变动而变动时，你很容易滥用 `watch`

```html
<div id="demo">
    {{ fullName }}
</div>
```

```Js
var vm = new Vue({
    el:'#demo',
    data: {
        firstName: 'Foo',
        lastName: 'Bar',
        fullName: 'Foo Bar',
    },
    watch:{
        firstName: function (val){
            this.fullName = val + ' ' + this.lastName
        },
        lastName: function (val){
            this.fullName = this.firstName + ' ' + val
        }
    }
})
```

**上面代码是命令式且重复的**将它与计算属性的版本进行比较：

```JS
var vm = new Vue({
    el: '#demo',
    data: {
        firstName: 'Foo',
        lastName: 'Bar'
    },
    computed: {
        fullName:function(){
           return this.firstName + ' ' + this.lastName
        }
    }
})
```

> 。。。。不明白这个例子，watch 只能监听字段的话，那坑定用计算属性函数啊...

### 计算属性的 setter

计算属性默认只有 getter, 不过在需要时你也可以提供一个 setter:

```JS
// ...
computed: {
    fullName: {
        // getter
        get: function (){
            return this.firstName + ' ' + this.lastName
        },
        // setter
        set: function (newValue){
            var name s = newValue.split(' ')
            this.firstName = names[0]
            this.lastName = names[names.length -1]
        }
    }
}
```

> 现在运行 `vm.fullName = 'John Doe'`时，setter 会被调用， `vm.firstName` 和 `vm.lastName`也会相应地更新

## 监听器

有时也需要一个自定义的监听器。**当需要在数据变化时执行异步或开销较大的操作时**，这个方法是最有用的。例如

```html
<div id = "watch-example">
    <p>
        Ask a yes/no question:
        <input v-model="question">
    </p>
    <p>
        {{ answer }}
    </p>
</div>
```

```js
<script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"></script>
var watchExampleVM = new Vue({
    el:'#watch-example',
    data:{
        question: '',
        answer:'I cannot give you an answer until you ask...'
    }
    watch:{
    	// 如果 question 发生改变，这个函数就会运行
    	question: function(newQuestion,oldQuestion){
    		this.answer = 'Waiting for you to stop typing...'
    		this.debouncedGetAnswer()
		}
	},
    created: function(){
        // loadsh 限制访问频率
        this.debouncedGetAnswer = _.debounce(this.getAnswer, 5000)
    },
    methods:{
        getAnswer: function () {
            // 如果没有 ? 这回答提示
            if(this.question.indexOf('?') === -1){
                this.answer = 'Questions usually contain a question'
                reutrn
            }
            this.answer = 'Thinking'
            var vm = this
            // 请求结果
            axios.get('https://yesno.wtf/apo')
           		.then(function (response){
                	vm.answer = _.capitalize(response.data.answer)  
            	})
            	.catch(function (error) {
                	vm.answer = 'Error! Could not reach the API.' + error
            	})
        }
    }
});
```

> 这个实例中，**使用 `watch` 选项允许我们执行异步操作(访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。**这些都是计算属性无法做到的

# Class 与 Style 绑定

操作元素的 class 列表和内联样式是数据绑定的一个常见需求。



## 绑定 HTML Class

### 对象语法

我们可以传个 `v-bind:class` 一个对象，以动态地切换 class:

```html
<div v-bind:class="{ active: isActive }" >
    
</div>
```

上面的依法表示`active`这个 class 存在与否将取决于数据 `property` isActive 的 布尔值



**可以在对象中传入更多字段动态切换多个 class 。此外，v-bind:class 指令也可以与普通的 class attribute 共存。** 

```html
<div class = "static"
     v-bind:class="{ active: isActive ,'text-danger': hasError}">
    
</div>
```

和如下 data：

```js
data: {
    isActive: true,
    hasError: false
}
```

结果渲染为：

```html
<div class="static active">
    
</div>
```

当 `isActove`或者 `hasError`变化时，class 列表将相应地更新。例如，如果 `hasError`的值为 `true`,class 列表将变为 "static active text-danger"

**绑定的数据对象不必内联定义在模版里：**

```html
<div v-bind:class ="classObject">
    
</div>
```

```js
data: {
    classObject: {
        active: true,
        'text-danger':false
    }
}
```

**我们也可以在这里绑定一个返回对象的计算属性**。这是一个常用且强大的模式：

```html
<div v-bind:class="classObject">
    
</div>
<script>
	data:{
        isActive:true,
        error: null
    },
    computed: {
        return {
            active: this.isActive && !this.error,
            'text-danger':this.error && this.error.type === 'fatal'
        }
    }
</script>
```

### 数组语法

我们可以把一个数组传给 `v-bind:class`,以应用一个 class 列表：

```html
<div v-bind:class="[activeClass,errorClass]">
    
</div>
```

```js
data:{
    activeClass,'active',
    errorClass:'text-danger'
}
```

渲染为：

```html
<div class="active text-danger">
    
</div>
<!-- 如果你也想根据条件转换列表中的 clas,可以用三元表达式 -->
<div v-bind:class="[isActive ? activeClass : '',errorClas]">
    
</div>
```

### 用在组件上

自定义组件也能使用 class 或 `v-bind:class=''`

## 绑定内联样式

### 对象语法

`v-bind:style` 的对象语法十分直观，看的像 CSS，但其实是一个 JS 对象。CSS property 名可以用驼峰式(camelCase) 或 短横线分割：

```html
<div v-bind:style="{ color:activeColor ,fontSize:fontSize}">
    
</div>
```

```JS
data:{
    activeColor:'red',
    fontSize: 30
}
```

**直接绑定到一个样式对象通常更好，这会让模版更清晰**

```html
<div v-bind:style="styleObject">
    
</div>
```

```JS
data:{
    styleObject:{
        color:'red',
        frontSize: '13px'
    }
}
```

对象语法常常结合返回对象的计算属性使用

### 数组语法

```html
<div v-bind:style="[baseStyles,overidingStyles]">
    
</div>
```

### 自动添加前缀

当 `v-bind:style`使用需要添加游览器引擎前缀的 `CSS property`时，如 `transform`,Vue.js 会自动侦测并添加相应的前缀

### 多重值

```html
<div :style="{ display:['-webkit-box','-ms-flexbox','flex']}">
    
</div>
```

如果游览器只支持不带游览器前缀的 flexbox，那么就只会渲染 `display:flex`

# 条件渲染

## v-if

我认为简单的直接提供示例

```html
<h1 v-if="awesome" >
   Vue is awesome! 
</h1>
<h1 v-else-if=type === 'B'"">
    Oh no 
</h1>
<!-- v-else 必需紧跟 v-if 或者 v-else-if 的元素后面 -->
<h1 v-else>
    Oh no 
</h1>
<!-- 在 template 元素上使用 v-if 条件渲染分组 -->
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template
```

> **用 `Key` 管理可复用的元素，Vue 会尽可能高效地渲染元素，通常会复用已有元素，而不是从头开始渲染。例如使用 `v-if` 和 `v-else` 切换，如果相同元素不会重新渲染，可以通过，元素是完全独立的，不要复用它们。只需添加具有唯一值的 `key attribute`即可** 

## v-show

根据条件展示元素，但是不通的是 **v-show 元素始终会被渲染并保留在 DOM 中，只是简单地切换元素的 CSS property dispaly**，

> `v-show` 不支持 `<template>` 元素，也不支持`v-else`
>
> - v-if 开销较大，如果需要频繁地切换，则使用 `v-show`较好

## v-if 与 v-for 一起使用

> 不推荐同时使用 `v-if`和`v-for`.`v-for` 具有比 `v-if`更高的优先级.当有条件的跳过循环的执行将 `v-if` 放于外层元素上。如：

```html
<ul v-if="todos.length">
    <li v-for="todo in todos">
        {{ todo }}
    </li>
</ul>
```



# 列表渲染

## 用 `v-for` 把一个数组对应为一组元素

```html
<ul id="example-1">
    <li v-for="item in items" :key="item.message">
        {{  item.message }}
    </li>
</ul>
```

```js
var example1 = new Vue({
    el: '#example-1',
    data:{
        items:[
            { message: 'Foo'},
            { message: 'Bar'}
        ]
    }
})
```

> **v-for 还支持一个可选的第二个参数，即当前项的索引**

```html
<ul id="example-2">
    <li v-for="(item,index) in items">
        {{ parentMessage }} - {{ index }} - {{ item.message }}
    </li>
</ul>
```

```js
var example2 = new Vue({
	el:'#example-2',
    data: {
        parentMessage: 'Parent',
        items: [
            { message: 'Foo' },
            { message: 'Bar' }s
        ]
    }
})
```

> **也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：**

```html
<div v-for="item of items">
    
</div>
```

## 在 v-for 里使用对象

你也可以用 `v-for` 来遍历一个对象的 property.**也可以提供第二个的参数为 property 名称(也就是键名)：**

```html
<div v-for="(value,name) in object">
    {{ name }} : {{ value }}
</div>
```

> 注意：在遍历对象时，会按 `Object.keys()`的结果遍历，但是不能保证它的结果在不通的 JS 引擎下都一致

## 维护状态

在渲染元素列表时，如果数据项顺序被改变，不会移动 DOM 元素来匹配数据项的顺序。为了给 Vue 一个提示，**以便它能跟踪每个节点的身份,从而重用和重新排序现有元素,你需要为每项提供一个唯一`key attribute`:**

```html
<div v-for = "item in items" v-bind:key="item.id">
    <!-- 内容 -->
</div>
```

## 数组更新测试

### 变更方法

**Vue 将被侦听的数组的变更方法**进行了包裹，所以他们也将会触发视图更新。

- `push()`
- `pop()`
- `shift()`
- `unshift()`
- `splice()`
- `sort()`
- `reverse()`

### 替换数组

会将变更调用了这些方法的原始数组。相比之下，`filter()、concat()和slice()`它们不会变更方法,**而总是返回一个新数组**当使用非变更方法时，可以用新数组替换旧数组:

```js
this.items = this,items.filter(function(item){
    return item.message.match(/Foo/)
})
```

## 显示过滤/排序后的结果

有时，我们想要显示一个**数组经过过滤或排序后**的版本，而不实际变更或重置原始数据。可以创建一个计算属性，来返回过滤或排序后的数组

```html
<li v-for="n in evenNumbers">{{ n }}</li>
```

```js
data: {
    numbers: [ 1,2,3,4,5 ]
},
computed:{
    evenNumbers: function(){
      return this.numbers.filter(function(number)){
      	return number % 2 === 0                             
    })
    }
}
```

可以在嵌套`v-for`循环中，你可以使用一个方法:

```html
<ul v-for="sert in sets">
    <li v-for="n in even(set)">{{ n }}</li>
</ul>

<script>
	data:{
        sets: [[1,2,3,4,5],[6,7,8,9,10]]
    },
    methods: {
        even: function(numbers){
            return numbers.filter(function (number){
                return number % 2 === 0
            })
        }
    }
</script>
```

## 在 v-for 里使用值范围

```html
<div>
    <span v-for="n in 10">{{ n }}</span>
</div>
```

## 在 `<template>` 上使用 v-for

```html
<ul>
    <template v-for="item in items">
    	<li>{{ item.msg }}</li>
        <li class="divider" role="presentation"></li>
    </template>
</ul>
```

## 在组件上使用 v-for

> 注意⚠️：2.2.0+ 的版本里，当在组件上使用 v-for 时，key 现在时必须的

然后任何数据都不会被自动传递到组件里，因为**组件有自定独立的作用域**，我们要使用 prop:

# 事件处理

## 监听事件

使用 `v-on`指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码

示例：

```html
<div id="example-1">
    <button v-on:click="counter += 1">
        Add 1
    </button>
    <p>
        {{counter}}
    </p>
</div>
<script>
	var example1 = new Vue({
        el:'#example-1',
        data: {
            counter: 0
        }
    })
</script>
```

## 事件处理方法

然而许多事件处理逻辑会更为复杂,所以直接把 JavaScript 代码写在 `v-on`指令中是不可行的. 因此 `v-on`还可以接受一个需要**调用的方法名称**

## 内联处理器中的方法