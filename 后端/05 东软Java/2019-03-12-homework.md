1:文件的数据流类型有哪些，并列举出部分类？<br>
2：线程和进程的区别<br>
3：线程的实现<br>

# 1:文件的数据流类型有哪些，并列举出部分类<br>
|    流分类   | 使用分类                 | 字节输入流               | 字节输出流                | 字符输入流           | 字符输出流          |
| :------: | -------------------- | ------------------- | -------------------- | --------------- | -------------- |
|          | 抽象基类                 | InputStream         | OutputStream         | Reader          | Writer         |
|    节点流   | 访问文件                 | FileInputStream     | FileOutStream        | FileReader      | FileWriter     |
||   访问数值   | ByteArrayInputStream | ByteArrayOutStream  | CharArrayReader      | CharArrayWriter |               
||   访问管道   | PipedInputStream     | PipedOutStream      | PipedReader          | PipedWriter     |               
||   访问字符串  | |                | StringReader         | StringWriter        |                                
|    处理流   |缓冲流                  | BufferedInputStream | BufferedOutputStream | BufferedReader  | BufferedWriter |
||    转换流   |  |                 |     InputStreamReader    | OutputStreamWriter  |                       
||    对象流   | ObjectInputStream    | ObjectOutputStream  |                      |                 |      
|| 抽象基类（过滤） | FilterInputStream    | FilterOutputStream  | FilterReader         | FilterWriter    |                
||    打印流  | | PrintStream          | |PrintWriter         |                  
||   推回输入流  | PushbackInputStream  || PushbackReader      |                      |                
||    特殊流   | DataInputStream      | DataOutputStream    |                      |                 |                |

# 2:线程和进程的区别<br>
1. 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

2. 线程的划分尺度小于进程，使得多线程程序的并发性高。

3. 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

4. 线程在执行过程中与进程还是有区别的。每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

5. 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

# 3:线程的实现<br>

**第一种方式：继承Thread类**
```java
public class ThreadDemo extends Thread {

	@Override
	public void run() {
		while (true) {
			System.out.println(Thread.currentThread().getName() + " is running ... "); // 打印当前线程的名字
			try {
				Thread.sleep(1000); // 休息1000ms
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public static void main(String[] args) {
		ThreadDemo td = new ThreadDemo();
		td.start(); // 启动线程

		while (true) {
			System.out.println(Thread.currentThread().getName() + " is running ... "); // 打印当前线程的名字
			try {
				Thread.sleep(1000); // 休息1000ms
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
```

**第二种方式：实现Runnable接口**

- 定义一个类实现Runnable接口，作为线程任务类
- 重写run方法，并实现方法体，方法体的代码就是线程所执行的代码
- 定义一个可以运行的类，并在main方法中创建线程任务类
- 创建Thread类，并将线程任务类做为Thread类的构造方法传入
- 启动线程

```java
public class ThreadTarget implements Runnable {

	@Override
	public void run() {
		while(true) {
			System.out.println(Thread.currentThread().getName() + " is running .. ");
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

}
public static void main(String[] args) {

		ThreadTarget tt = new ThreadTarget(); // 实例化线程任务类
		Thread t = new Thread(tt); // 创建线程对象,并将线程任务类作为构造方法参数传入
		t.start(); // 启动线程

		// 主线程的任务，为了演示多个线程一起执行
		while(true) {
			System.out.println(Thread.currentThread().getName() + " is running .. ");
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

```

**第三种方式：使用内部类的方式**

```java
public static void main(String[] args) {

		// 基于子类的实现
		new Thread() {
			public void run() {
				while (true) {
					System.out.println(Thread.currentThread().getName() + " is running ... "); // 打印当前线程的名字
					try {
						Thread.sleep(1000); // 休息1000ms
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			};
		}.start();

		// 基于接口的实现
		new Thread(new Runnable() {
			@Override
			public void run() {
				while (true) {
					System.out.println(Thread.currentThread().getName() + " is running ... "); // 打印当前线程的名字
					try {
						Thread.sleep(1000); // 休息1000ms
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}
		}).start();

		// 主线程的方法
		while (true) {
			System.out.println(Thread.currentThread().getName() + " is running ... "); // 打印当前线程的名字
			try {
				Thread.sleep(1000); // 休息1000ms
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}

	}

```
**第四种方式：定时器**
```java
/**
 * 定时器举例
 *
 */
public class TimerDemo {

	private static final SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

	public static void main(String[] args) throws Exception {
		Timer timer = new Timer();
		timer.schedule(new TimerTask() {
			@Override
			public void run() {
				System.out.println("定时任务执行了....");
			}
		}, format.parse("2017-10-11 22:00:00"));
	}

}
```
**第五种方式：带返回值的线程实现方式**

1. 创建一个类实现Callable接口，实现call方法。这个接口类似于Runnable接口，但比Runnable接口更加强大，增加了`异常`和`返回值`。
2. 创建一个FutureTask，指定Callable对象，做为线程任务。
3. 创建线程，指定线程任务。
4. 启动线程

```java
public class CallableTest {

	public static void main(String[] args) throws Exception {
		Callable<Integer> call = new Callable<Integer>() {

			@Override
			public Integer call() throws Exception {
				System.out.println("thread start .. ");
				Thread.sleep(2000);
				return 1;
			}
		};

		FutureTask<Integer> task = new FutureTask<>(call);
		Thread t =  new Thread(task);

		t.start();
		System.out.println("do other thing .. ");
		System.out.println("拿到线程的执行结果 ： " + task.get());
	}

}

```

**第六种方式：基于线程池的方式**

```java
public class ThreadPoolDemo {

	public static void main(String[] args) {

		// 创建线程池
		ExecutorService threadPool = Executors.newFixedThreadPool(10);

		while(true) {
			threadPool.execute(new Runnable() { // 提交多个线程任务，并执行

				@Override
				public void run() {
					System.out.println(Thread.currentThread().getName() + " is running ..");
					try {
						Thread.sleep(3000);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			});
		}
	}

}

```

**Spring方式：使用Spring来实现多线程**

`我们可以通过Spring的@Async注解非常方便的实现多线程。`
