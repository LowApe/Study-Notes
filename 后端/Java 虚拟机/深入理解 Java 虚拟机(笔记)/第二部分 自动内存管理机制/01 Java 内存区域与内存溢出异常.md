# Java 内存区域与内存溢出异常

## 概述
Java 与 C++ 之前有一堵由**内存动态分配**和**垃圾收集技术**所围成的高墙


|| C、C++ 程序员     | Java程序员     |
|:------| :------------- | :------------- |
|特点| 拥有每一个对象的"所有权"       | 虚拟机**自动内存管理机制**       |
|优势|可以精准控制|不需要为每个对象编写 delete/free 代码，不容易出现**内存泄漏**和**内存溢出**|
|劣势|操作不当，容易内存泄漏和内存溢出|一旦出现内存泄漏和内存溢出，不了解虚拟机是怎么使用内存的，那么**排查**异常会非常**困难**|


## 运行时数据区域

Java虚拟机在**执行**Java程序的过程中会把它管理的**内存划分**为若干个不同的**数据区域**,这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着**虚拟机进程的启动**而存在，有些区域则依赖**用户线程的启动和结束**而创建和销毁。

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g7pgehor73j30m80igq6n.jpg)

### 程序计数器
程序计数器是一块较小的内存空间，它可以看作是**当前线程**执行的**字节码的行号指示器**

在虚拟机的概念模型里，字节码解释器工作时就是通过**改变计数器的值**来选择下一条需要执行的**字节码指令**。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器

> 由于Java虚拟机的多线程是通过**线程轮流切换**并**分配**处理器**执行时间**的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都**只会执行一条线程中的指令**。因此线程切换后恢复到正确的执行位置，都需要有独立的程序计数器，**各线程之间计数器互不影响**，独立存储，我们称这类内存区域为**线程私有**的内存

> ⚠️提示：如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的**虚拟机字节码指令的地址**；如果正在执行的是 Natvie 方法，这个计数器则为空（Undefined）。此内存区域是**唯一一个**在Java虚拟机规范中没有规定任何 `OutOfMemoryError`情况的区域

### Java虚拟机栈
与程序计数器一样，Java虚拟机栈也是**线程私有**的，它的生命周期与线程相同。

虚拟机栈描述的是Java**方法执行**的内存模型：每个方法执行的同时都会创建一个**栈帧(Stack Frame)** 用于存储 `局部变量表`、 `操作数栈` 、`动态链接`、`方法出口`等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中**入栈到出栈**的过程

局部变量表存放了**编译期**可知的各类`基本数据类型`、`对象引用类型`、`returnAddress类型`

> ⚠️提示：其中64位长度的 long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。局部变量表所需要的内存空间`在编译期间完成分配`，当进入一个方法时，这个方法需要的`帧`中分配多大的`局部变量空间是完全确定的`，在方法运行期间不会改变局部变量表的大小

Java区域规定了两种异常情况：
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 `StackOverflowError`异常
- 如果虚拟机可以动态扩展时无法申请到足够的内存空间，则会抛出 `OutOfMemoryError`异常

### 本地方法栈
本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法方法(**也就是字节码**)服务，而本地方法栈则为虚拟机使用的**Native方法**服务

> ⚠️注意：在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如Sun 的HotSot虚拟机)直接把本地方法与虚拟机栈合二为一

### Java 堆
Java堆(Java Heap)是Java 虚拟机所管理的内存中最大的一块。Java堆是被所有**线程共享**的一块内存区域，在**虚拟机启动时创建**。此内存区域的唯一目的就是**存放对象实例**，几乎所有的对象实例都在这里**分配内存**

> ⚠️注意：在Java虚拟机规范中这样描述：所有的对象实例以及数组都在`堆上分配`，但是随着JIT编译器的发展与`逃逸分析`技术逐渐成熟，`栈上分配`、`标量替换`优化技术将会导致不一定所有的对象都在栈上分配

Java 堆是垃圾收集管理的主要区域，因为很多时候也被称为`GC堆`，用于现在收集器基本都采用**分代收集算法**，所有Java堆还可以细分：新生代与老生代：在细致点的有 Eden空间、From Survivor 空间、To Surviror 空间、ToSurvior 空间等。从分配的角度来看，线程共享的Java堆中可能划分出**多个线程私有的**分配缓冲区TLAB。

无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例。进一步划分的目的是为了更好的**回收内存**，或更快地**分配内存**

> ⚠️注意：Java堆可以处于物理上**不连续的内存**空间，只要**逻辑连续**。当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms来控制)。如果在堆中没有内存完成实例分配，并且堆也无法扩展时，将会抛出`OutOfMemoryError`异常

### 方法区

方法区与Java堆一样，是**各个线程共享**的内存区域，他用于存储已被**虚拟机加载**的`类信息`、`常量`、`静态变量`、`即时编译器编译后的代码`等数据。虽然Java虚拟机规范把方法区描述为**堆**的逻辑部分，其目的是将Java堆区分开来。

习惯于 HotSpot 虚拟机上开发、部署程序的开发者来说，很多人更愿意把方法区称为"永久代"，本质上两者并不等价，仅仅是因为 HotSpot 虚拟机的设计团队选择把 **GC分代收集扩展** 至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作

> ⚠️注意：对于其他虚拟机(BEA JRockit、IBM J9)来说是不存在永久代来实现方法区，原则上，如果实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题(永久代有 -XX：MaxPermSize的上限，J9和Rockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题)，而且有极少数方法(例如String.intern())会因这个原因导致不同虚拟机下有不同的表现。对于 HotSpot 虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为采用 `Native Memory`来实现方法区的规划，JDK1.7的 HotSpot 中，已经把原本放在永久代的`字符串常量池`移出


Java 虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者扩展外，还可以选择**不实现垃圾收集**。相对而言垃圾收集在这个区域的内存是比较少出现的，但并非数据进入方法区就如用生代名字一样永久存在。这个区域的内存回收目标只要是针对**常量池的回收和对类型的卸载**

> Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出`OutOfMemoryError`异常

### 运行时常量池
运行时常量池(Runtime Constant Pool)是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池**，用于存放**编译期**生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的**运行时常量池**中存放

Java虚拟机对Class文件每部分格式都有严格规定。每个字节用于存储那种数据必须符合规范的要求才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要实现这个内存区域。

运行时常量池相对于**Class文件常量池**的另一个重要特性是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能放入池中。例如：String.intern() 方法

> 运行时常量池属于方法区一部分，所以放常量池无法再申请到内存时，将抛出`OutOfMemoryError`异常


### 直接内存

直接内存既不是虚拟机运行时数据区域，也不是Java虚拟机规范定义的内存区域。但是这部分也是频繁使用，而且可能导致内存溢出异常

在JDK 1.4 新加入 NIO(New Input/Output)，引入一种**基于通道**与**缓存区**的I/O方式，它可以使用Native函数库直接分配**堆外内存**，然后通过一个存储在Java堆中的**DirectByteBuffer对象**作为这块内存的引用进行操作。这样能在一些场景中显著提供性能，因为避免在Java堆和Native堆中来回复制数据

> ⚠️注意：本机直接内存的分配并不会受到 Java 堆大小的限制，但是既然是内存，肯定还会受到本机总内存(包括RAM和SWAP区或者分页文件)大小及处理器寻址空间的大小。服务器管理员在配置`虚拟机参数时`，会根据实际内存设置 `-Xmx`等参数信息。如果忽略了直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致`动态扩展`而造成`OutOfMemoryError`异常
