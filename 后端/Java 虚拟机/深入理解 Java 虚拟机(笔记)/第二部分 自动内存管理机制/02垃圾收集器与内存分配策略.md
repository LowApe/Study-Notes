# 垃圾收集器与内存分配策略

Java 与 C++ 之间有一堵由**内存动态收集和垃圾收集技术**所围成的“高墙”。

## 概述

垃圾收集（Garbage Collection,GC）大部分人都把这项技术当做 Java 的伴生产物。下面有三个问题需要思考

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

栈中的栈帧随着方法的进入和退出而有条不乱地执行着出栈和入栈操作。每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由 JIT 编译期进行一些优化，本章基于概念模型的讨论中，大体上可以认为是编译期可知）因此在程序计数器、虚拟机栈、本地方法栈这三个随着县城启动的就不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。而**Java 堆和方法区**则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序**处于运行期间时**才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，后面讨论的内存分配和回收也是这一部分内存



## 对象已死吗(判定)

垃圾收集器在进行回收钱，第一件事就要确定这些对象哪些存活，哪些死去

### 引用计数算法

> 给对象中添加一个**引用计数器**，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器就减1；任何时刻计数器为 0 的对象就是不可能再被使用的。

不使用的原因:很难解决对象之间相互循环引用的问题。

下面代码添加VM 参数`-verbose:gc: -Xms20M -Xmx20M -Xmn10M -verbose:gc -XX:+PrintGCDetails -XX:SurvivorRatio=8`

```java
/**
 * testGC()方法执行后， objA 和 objB 会不会被 GC 呢？
 * 
 */
public class ReferenceCountingGC{
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在 GC 日志中看清楚是否被回收过
     */
    private byte[] bigSize = new byte[2* _1MB];
    
    private static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        
        objA = null;
        objB = null;
        
        // 假设在这行发生 GC， objA 和 objB 是否能被回收？
        System.gc(); 
     }
}
```



```shell
[GC (System.gc()) [PSYoungGen: 5954K->624K(9216K)] 5954K->632K(19456K), 0.0014494 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 624K->0K(9216K)] [ParOldGen: 8K->452K(10240K)] 632K->452K(19456K), [Metaspace: 2948K->2948K(1056768K)], 0.0051610 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 9216K, used 164K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 8192K, 2% used [0x00000007bf600000,0x00000007bf6290e0,0x00000007bfe00000)
  from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)
  to   space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)
 ParOldGen       total 10240K, used 452K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
  object space 10240K, 4% used [0x00000007bec00000,0x00000007bec71070,0x00000007bf600000)
 Metaspace       used 2961K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 322K, capacity 388K, committed 512K, reserved 1048576K
```

运行结果， `5954K->624K(9216K)` 虚拟机并没有因为这两个对象互相引用就不回收它们.侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的

### 可达性分析算法

> 通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链(Reference Chain)**,当一个对象到 GC Roots 没有任何引用链相连(图论的话来说,就是从 GC Roots 到这个对象不可达) 时，则证明此对象是不可用的。

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8yfxm6hwnj31040jotco.jpg)

上图左边是仍然存活的对象，右边判定可回收的对象。虽然Object 3、4、5 之间存在互相有关联，但是它们到 **GC Roots 是不可达**的，所以它们将判定为是可回收的对象。



在 Java 语言中。可作为 GC Roots 的对象包括下面几种：

- 虚拟机栈(栈帧中的本地变量表)中引用的的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI (即一般说的 Native 方法) 引用的对象

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8yggrle61j31460kywhf.jpg)

> ⚠️注意：判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与"引用"有关。

### 再谈引用

JDK 1.2 之前，reference 类型的数据中存储的数值代表的另外一块内存的起始地址，就称为这块内存代表着一个引用。对象存在引用和没有被引用两种状态，当内存还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。

JDK 1.2 之后

- 强引用：类似 “Object obj = new Object()” 这类的引用，只要强引用好存在，垃圾收集器永远不会回收掉被引用的对象
- 软引用：用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生**内存溢出异常之前**，将会把这些对象**列进回收范围之中**进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用

- 弱引用：也是用来描述一些非必需对象的，但是它的强度比软引用更弱，被**弱引用关联的对象只能生存到下一次垃圾收集发生之前**。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。
- 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知，提供了 PhantomReference 类来实现虚引用

### 生存还是死亡

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候他们可以暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程；

1. 对象可达性分析算法，如果对象不可达，，则被**第一次标记**
2. 筛选出对象**有必要执行 finalize() 方法**，将它放入 F-Queue 队列中
3. 虚拟机根据队列创建 Finalizer 线程去触发这个方法（但并不会承诺等待它运行结束，将可能导致整个内存回收系统崩溃）
4. finalize()方法是对象逃脱死亡命运的最后一次机会。稍后 GC 将对 F-Queue 中的对象进行**第二次小规模的标记**
5. 如果对象要在 finalize() 方法成功拯救自己，只要重新与引用链上的任何一个对象关联即

> 💡提示：
>
> - 没有必要执行：没有覆盖 finalize() 方法，或者 finalize() 方法已经调用过

```java
public class FinalizeEscapeGC{
    public static FinalizeEscapeGC SAVE_HOOK = null;
    
    public void isALive(){
        System.out.println("yes, i am still alive:");
    }
    
    @Override
    protected void finalize() throws Throwable{
        super.finalize();
        System.out.println("finalize method executed !");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }
    public static void main(String[] args) throws Throwable{
        SAVE_HOOK = new FinalizeEscapeGC();
        
        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        //因为 finalize 方法优先级很低，所欲暂停 0.5 秒以等待它
        Thread.sleep(500);
        if(SAVE_HOOK != null){
            SAVE_HOOK.isALive();
        }else{
            System.out.println("no, i am dead :(");
        }
    }
}
```

上面代码流程

1. 可达性分析算法发现对象 `SAVE_HOOK` 对象 `GC Roots` 引用不可达，进行第一次标记
2. 执行垃圾回收，因为覆盖了 `finalize()` 方法，并且虚拟机并没调用过该方法则有必要将对象放入 `F-Queue `队列中
3. 虚拟机触发这个方法,方法内将 `SAVE_HOOK` 继续引用到了引用链，则对象不会被回收
4. 第二次执行垃圾回收，因为虚拟机执行过 `finalize()` 方法则没必要执行 `finalize()`,所有添加不上`GC Roots` 引用，所有被回收

> ⚠️注意：因为任何一个对象的 `finalize()`方法都只会被系统自动调用一次，因此第二次无法在`finalize()`方法中添加引用，所以被回收了

### 回收方法区

Java 虚拟机规范中确实说过可以**不要求**虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比” 一般比较低.永久代的垃圾收集主要回收两部分内容：

- 废弃常量
	- 例如字符串 “abc” 已经进入了常量池中，但是当前系统没有任何一个 String 对象是叫做 "abc",也就是没有任何 String 对象引用常量池中的 “abc” 常量，如果这时发生内存回收，而且必要的话，这个 “abc” 常量就会被系统清理出常量池。**常量池中的其他类(接口)、方法、字段的符号引用与此类似**
- 无用的类
	- 判定无用累需要**同时满足**下面 3 个条件：
		- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例
		- 加载该类的 ClassLoader 已经被回收
		- 该类对应的 java.lang.Class 对象没有在在任何地方被引用，无法在任何地方通过反射访问该类的方法

> HotSpot 虚拟机提供了 `-Xnolassgc` 参数进行控制，还可以`-verbose:class`以及`-XX:+TraceClassLoading`、`-XX:+TraceClassUnLoading`查看类加载和卸载信息，其中`-verbose:class`和`-XX:+TraceClassloading` 可以在 Product 版的虚拟机中使用，`-XX:+TraceClassUnloading`参数需要 FastDebug 版的虚拟机支持

在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出

> 这块第二次理解还是不清楚

## 垃圾收集算法(查找)

介绍垃圾收集算法的思想及其发展过程

### 标记 - 清除算法

最基础的收集算法是“标记 - 清除”(Mark-Sweep) 算法，如同它的名字一样，算法分为**"标记"**和**“清除”**两个阶段：首先标记出所有需要回收的对象。在标记完成后统一回收所有被标记的对象。之所以说它是**最基础**的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。两个不足：

- 效率问题
- 空间问题
	- 标记清楚之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8z02ph0c0j30pa0cqjvr.jpg)

### 复制算法

根据标记清除算法的空间算法的不足，它将可用内存按容量划分大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上，然后再把已使用过的内存空间一次清理掉。这样内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效**代价是将内存缩小为了原来的一半**未免太高了一点。

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8z0jpcetqj30qw0d2dsf.jpg)

IBM 公司的专门研究表明，新生代中的对象 98% 是 “朝生夕死” 的，所以并不需要按照 `1:1` 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和 其中一块 Survivor,当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 `8:1`，也就是每次新生代中可用内存空间为整个新生代容量的 90%(80% + 10%),只有 10% 的内存会被 “浪费”。

当 Survivor 空间不够用时，需要依赖其他内存(老年代)进行分配担保。

网上关于新生代与老生代的信息:[Java新生代、老生代和永久代详解](https://www.jianshu.com/p/d3a0b4e36c28)

### 标记-整理算法

复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50 % 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有**对象都 100% 存活的极端情况**，所有在老年代一般不能直接选用这种算法

根据老年代的特点，有人提出了另外一种“标记 - 整理”(Mark-Compact)算法，标记过程任然与“标记 - 清除”算法一样  ，但后续不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后**直接清理掉端边界以外**的内存，“标记 - 整理” 算法的示意图

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8zmh7v5alj30q00d6jw0.jpg)

### 分代收集算法

根据**对象存活周期**的不同将内存划分为几块。一般是把 Java 堆分为新生代和老生代，这样就可以根据各个年代的特点采用最适合的收集算法。

- 新生代
	- 每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选复制算法
- 老年代
	- 老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记 - 清理”或者 “标记 - 整理” 算法来进行回收



## HotSopt 的算法实现(查找)

前面两个介绍了**对象存活判定**算法和**垃圾收集**算法，

而在 HotSpot 虚拟机上实现这些算法时，必须对算法的执行效率严格的考量，才能保证虚拟机高效运行。

### 枚举根节点

可达性分析对执行时间的敏感还体现在 GC 停顿上，因为这项分析工作必须在一个能确保**一致性的快照**中进行。

> 一致性指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果就无法得到保证。这点是导致 GC 进行时必须停顿所有 Java 执行线程的其中一个重要原因，即使是在号称不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。

所有当执行系统停顿下来后，并不需要一个不漏地检查完所有**执行上下文**和**全局的引用**位置，虚拟机应当直接知道哪些地方存放着对象引用。在 HotSpot 的实现中，是使用一组称为 **OopMap 的数据结构**来达到这个目的的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在**JIT 编译**过程中，也会在特定的位置**记录下栈和寄存器**中哪些位置是引。

>  可作为 GCRoots 的节点主要在**全局性的引用**(常量、类静态属性)与**执行上下文**(栈的本地变量表)

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8zo9ze5kjj30q40nojyn.jpg)



### 安全点

在 OopMap 的协助下， HotSpot 可以快速准确地完成 GC Roots 枚举，但一个很现实的问题随之而来：可以导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap ，那将会需要大量的，那将会需要大量的额外空间，这样 GC 的空间成本将会变得很高。

只是在 “特定的位置” 记录了这些信息，这些位置称为**安全点(Safepoint)**，即程序执行时并非在所有地方都停顿下来开始 GC，只有在到达安全点时才能暂停。

- 安全点的选定既不能太少以至于让 GC 等待时间太长
- 也不能过于频繁以致于过分增大运行时的负荷。

所以，安全点的选定基本上是以程序"是否具有让程序长时间执行的特征"为标准进行选定的，也不能过于频繁以致于过分增大运行时的负荷。

指令序列复用(在安全点上？)：

1. 方法调用
2. 循环跳转
3. 异常跳转

如何在 GC 发生时让所有线程(这里不包括执行 JNI 调用的线程)都 “跑” 到最近的安全点上再停顿下来。

- 抢先式中断
	- 不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不再安全点上，就恢复线程，让其**跑到**安全点上。(弃用)
- 主动式中断
	- 当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。

### 安全区域

安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的安全点。但是，程序“不执行”的时候？程序不执行就是没有分配 CPU 时间，典型的例子就是线程处于 Sleep 状态或者 Blocked 状态，这是时候线程无法响应 JVM 的中断请求，“走” 到安全的地方去中断挂起，JVM 也显然不太可能等待线程重新被分配 CPU 时间。对于这种情况，就需要**安全区域**来解决

> 安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任意地方开始 GC 都是安全的，我们也可以把安全区域看做是被扩展了的安全点

在线程执行到安全区域，首先标识自己**已经进入**了安全区域，那样，当在这段时间里 JVM 要发起 GC 时，就不用管标识自己为安全区域状态的线程了。线程离开安全区域检查是否完成了根节点枚举(或者是整个 GC 过程)，如果完成了，那线程就继续执行，否则等待。因为**内存回收**如何进行是由虚拟机所采用的 GC 收集器决定的，而通常虚拟机中往往不止有一种 GC 收集器。

## 垃圾收集器



