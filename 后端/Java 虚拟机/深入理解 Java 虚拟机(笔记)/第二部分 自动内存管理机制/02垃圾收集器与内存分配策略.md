# 垃圾收集器与内存分配策略

Java 与 C++ 之间有一堵由**内存动态收集和垃圾收集技术**所围成的“高墙”。

## 概述

垃圾收集（Garbage Collection,GC）大部分人都把这项技术当做 Java 的伴生产物。下面有三个问题需要思考

- 哪些内存需要回收？
- 什么时候回收？
- 如何回收？

栈中的栈帧随着方法的进入和退出而有条不乱地执行着出栈和入栈操作。每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由 JIT 编译期进行一些优化，本章基于概念模型的讨论中，大体上可以认为是编译期可知）因此在程序计数器、虚拟机栈、本地方法栈这三个随着县城启动的就不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。而**Java 堆和方法区**则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序**处于运行期间时**才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，后面讨论的内存分配和回收也是这一部分内存



## 对象已死吗

垃圾收集器在进行回收钱，第一件事就要确定这些对象哪些存活，哪些死去

### 引用计数算法

> 给对象中添加一个**引用计数器**，每当有一个地方引用它时，计数器值就加 1；当引用失效时，计数器就减1；任何时刻计数器为 0 的对象就是不可能再被使用的。

不使用的原因:很难解决对象之间相互循环引用的问题。

下面代码添加VM 参数`-verbose:gc: -Xms20M -Xmx20M -Xmn10M -verbose:gc -XX:+PrintGCDetails -XX:SurvivorRatio=8`

```java
/**
 * testGC()方法执行后， objA 和 objB 会不会被 GC 呢？
 * 
 */
public class ReferenceCountingGC{
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在 GC 日志中看清楚是否被回收过
     */
    private byte[] bigSize = new byte[2* _1MB];
    
    private static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        
        objA = null;
        objB = null;
        
        // 假设在这行发生 GC， objA 和 objB 是否能被回收？
        System.gc(); 
     }
}
```



```shell
[GC (System.gc()) [PSYoungGen: 5954K->624K(9216K)] 5954K->632K(19456K), 0.0014494 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 624K->0K(9216K)] [ParOldGen: 8K->452K(10240K)] 632K->452K(19456K), [Metaspace: 2948K->2948K(1056768K)], 0.0051610 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
Heap
 PSYoungGen      total 9216K, used 164K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
  eden space 8192K, 2% used [0x00000007bf600000,0x00000007bf6290e0,0x00000007bfe00000)
  from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)
  to   space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)
 ParOldGen       total 10240K, used 452K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
  object space 10240K, 4% used [0x00000007bec00000,0x00000007bec71070,0x00000007bf600000)
 Metaspace       used 2961K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 322K, capacity 388K, committed 512K, reserved 1048576K
```

运行结果， `5954K->624K(9216K)` 虚拟机并没有因为这两个对象互相引用就不回收它们.侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的

### 可达性分析算法

> 通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链(Reference Chain)**,当一个对象到 GC Roots 没有任何引用链相连(图论的话来说,就是从 GC Roots 到这个对象不可达) 时，则证明此对象是不可用的。

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8yfxm6hwnj31040jotco.jpg)

上图左边是仍然存活的对象，右边判定可回收的对象。虽然Object 3、4、5 之间存在互相有关联，但是它们到 **GC Roots 是不可达**的，所以它们将判定为是可回收的对象。



在 Java 语言中。可作为 GC Roots 的对象包括下面几种：

- 虚拟机栈(栈帧中的本地变量表)中引用的的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI (即一般说的 Native 方法) 引用的对象

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8yggrle61j31460kywhf.jpg)

> ⚠️注意：判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与"引用"有关。

### 再谈引用

JDK 1.2 之前，reference 类型的数据中存储的数值代表的另外一块内存的起始地址，就称为这块内存代表着一个引用。对象存在引用和没有被引用两种状态，当内存还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。

JDK 1.2 之后

- 强引用：类似 “Object obj = new Object()” 这类的引用，只要强引用好存在，垃圾收集器永远不会回收掉被引用的对象
- 软引用：用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生**内存溢出异常之前**，将会把这些对象**列进回收范围之中**进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用

- 弱引用：也是用来描述一些非必需对象的，但是它的强度比软引用更弱，被**弱引用关联的对象只能生存到下一次垃圾收集发生之前**。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK 1.2 之后，提供了 WeakReference 类来实现弱引用。
- 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知，提供了 PhantomReference 类来实现虚引用

### 生存还是死亡

即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候他们可以暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程；

1. 对象可达性分析算法，如果对象不可达，，则被**第一次标记**
2. 筛选出对象**有必要执行 finalize() 方法**，将它放入 F-Queue 队列中
3. 虚拟机根据队列创建 Finalizer 线程去触发这个方法（但并不会承诺等待它运行结束，将可能导致整个内存回收系统崩溃）
4. finalize()方法是对象逃脱死亡命运的最后一次机会。稍后 GC 将对 F-Queue 中的对象进行**第二次小规模的标记**
5. 如果对象要在 finalize() 方法成功拯救自己，只要重新与引用链上的任何一个对象关联即

> 💡提示：
>
> - 没有必要执行：没有覆盖 finalize() 方法，或者 finalize() 方法已经调用过

```java
public class FinalizeEscapeGC{
    public static FinalizeEscapeGC SAVE_HOOK = null;
    
    public void isALive(){
        System.out.println("yes, i am still alive:");
    }
    
    @Override
    protected void finalize() throws Throwable{
        super.finalize();
        System.out.println("finalize method executed !");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }
    public static void main(String[] args) throws Throwable{
        SAVE_HOOK = new FinalizeEscapeGC();
        
        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        //因为 finalize 方法优先级很低，所欲暂停 0.5 秒以等待它
        Thread.sleep(500);
        if(SAVE_HOOK != null){
            SAVE_HOOK.isALive();
        }else{
            System.out.println("no, i am dead :(");
        }
    }
}
```

上面代码流程

1. 可达性分析算法发现对象 SAVE_HOOK 对象 GC Roots 引用不可达，进行第一次标记
2. 执行垃圾回收，因为覆盖了 finalize() 方法则有必要将对象放入 F-Queue 队列中
3. 虚拟机触发这个方法,方法内将 SAVE_HOOK 继续引用到了引用链，则对象不会被回收

第一次运行结果

`finalize method executed !
yes, i am still alive:`

第二次将`FinalizeEscapeGC.SAVE_HOOK = this;`注释，则运行结果。

`finalize method executed !
no, i am dead :(`

> 建议不使用 finalize() ，使用 try-finally 或者其他方式都可以做得更好

### 回收方法区

Java 虚拟机规范中确实说过可以**不要求**虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比” 一般比较低.永久代的垃圾收集主要回收两部分内容：

- 废弃常量
	- 例如字符串 “abc” 已经进入了常量池中，但是当前系统没有任何一个 String 对象是叫做 "abc",也就是没有任何 String 对象引用常量池中的 “abc” 常量，如果这时发生内存回收，而且必要的话，这个 “abc” 常量就会被系统清理出常量池。**常量池中的其他类(接口)、方法、字段的符号引用与此类似**
- 无用的类
	- 判定无用累需要**同时满足**下面 3 个条件：
		- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例
		- 加载该类的 ClassLoader 已经被回收
		- 该类对应的 java.lang.Class 对象没有在在任何地方被引用，无法在任何地方通过反射访问该类的方法

> HotSpot 虚拟机提供了 `-Xnolassgc` 参数进行控制，还可以`-verbose:class`以及`-XX:+TraceClassLoading`、`-XX:+TraceClassUnLoading`查看类加载和卸载信息，其中`-verbose:class`和`-XX:+TraceClassloading` 可以在 Product 版的虚拟机中使用，`-XX:+TraceClassUnloading`参数需要 FastDebug 版的虚拟机支持

在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出

## 垃圾收集算法