#  强引用、软引用、弱引用、幻象引用有什么区别？

引用:在 Java 语言中，除了原始数据类型的变量，其他所有都是所谓的`引用类型`，指向各种不同的对象，理解引用对于掌握 Java 对象`生命周期`和 `JVM `内部相关机制非常有帮助。

## 典型回答
不同的引用类型,主要体现的时对象不同的`可达性状态`和`对垃圾收集`的影响.

- 强引用,就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。

- 软引用:是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象.JVM 会确保在抛出
OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时,不会耗尽内存。

- 弱引用:并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。

- 对于幻象引用:有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，我在专栏上一讲中介绍的 Java 平台自身 Cleaner 机制等，也有人利用幻象引用监控对象的创建和销毁。

----
充分理解这些引用，对于我们设计可靠的缓存等框架，或者诊断应用 OOM 等问题，会很有帮助。比如，诊断 `MySQL connector-j` 驱动在特定模式下`useCompression=true`的内存泄漏问题，就需要我们理解怎么排查幻象引用的堆积问题

## 知识扩展
1. 对象可达性状态流转分析
![](http://ww1.sinaimg.cn/large/006rAlqhly1g16yswmessj30bo0i6q4b.jpg)

我来解释一下上图的具体状态，这是 Java 定义的不同可达性级别（reachability level）
- 强可达（Strongly Reachable），就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。
- 软可达（Softly Reachable），就是当我们只能通过软引用才能访问到对象的状态。
- 弱可达（Weakly Reachable），类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。这是十分临近 finalize 状态的时机，当弱引用被清除的时候，就符合 finalize 的条件了。
- 幻象可达（Phantom Reachable），上面流程图已经很直观了，就是没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候。当然，还有一个最后的状态，就是不可达（unreachable），意味着对象可以被清除了。

****

判断对象可达性,是 JVM 垃圾收集器决定如何处理对象的一部分考虑.所有应用类型,都是抽象类 java.lang.ref.Reference 的子类,里面有个 get() 方法:

除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态！这也是为什么我在上面图里有些地方画了双向箭头。所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。

但是，你觉得这里有没有可能出现什么问题呢？

不错，如果我们错误的保持了强引用（比如，赋值给了 static 变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。所以，检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路，如果我们的框架使用到弱引用又怀疑有内存泄漏，就可以从这个角度检查。

2. 引用队列(ReferenceQueue)使用

3. 显式地影响软引用垃圾收集

4. 诊断 JVM 引用情况
如果你怀疑应用存在引用（或 finalize）导致的回收问题，可以有很多工具或者选项可供选择，比如 `HotSpot JVM `自身便提供了明确的选项`PrintReferenceGC`去获取相关信息，我指定了下面选项去使用 JDK 8 运行一个样例应用：
```shell
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintReferenceGC
```

5. Reachability Fence

```java
class Resource {
    private static ExternalResource[] externalResourceArray = ...
    int myIndex; Resource(...) {
        myIndex = ...
        externalResourceArray[myIndex] = ...;
 ...
    }
    protected void finalize() {
        externalResourceArray[myIndex] = null;
 ...
    }
    public void action() {
        try {
            // 需要被保护的代码
            int i = myIndex;
            Resource.update(externalResourceArray[i]);
        } finally {
            // 调用 reachbilityFence，明确保障对象 strongly reachable
            Reference.reachabilityFence(this);
        }
    }
    private static void update(ExternalResource ext) {
        ext.status = ...;
    }
   }
```

****
## 用户总结
在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其
生命周期的长短，将引用分为4类。

1. 强引用<br>
特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。

2. 软引用<br>
特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError `之前`，清理软引用指向的对象。<br><br>
软引用可以和一个引用队列ReferenceQueue联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。
<br>
**应用场景：**软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

3. 弱引用<br>
弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
<br>**应用场景：**弱应用同样可用于内存敏感的缓存

4. 虚引用<br>
特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
```java
ReferenceQueue queue = new ReferenceQueue ();
PhantomReference pr = new PhantomReference (object, queue);
```
程序可以通过判断`引用队列中`是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存`被回收之前`采取一些程序行动。<br>
**应用场景：**可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集
器回收之前会收到一条系统通知。
