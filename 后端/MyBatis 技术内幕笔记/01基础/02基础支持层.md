# åŸºç¡€æ”¯æŒå±‚

## 1 è§£æå™¨æ¨¡å—

åœ¨ MyBatis ä¸­æ¶‰åŠå¤šä¸ª XML é…ç½®æ–‡ä»¶ï¼Œå› æ­¤æˆ‘ä»¬é¦–å…ˆä»‹ç» `XMLè§£æ`çš„ç›¸å…³å†…å®¹ã€‚XMLè§£æå¸¸è§çš„æ–¹å¼æœ‰ä¸‰ç§ï¼Œåˆ†åˆ«æ˜¯ï¼š

- DOM(Document Object Model)è§£ææ–¹å¼
- SAX(Simple API for XML)è§£ææ–¹å¼ï¼Œ
-  JDK 6.0 ç‰ˆæœ¬å¼€å§‹ï¼ŒJDKå¼€å§‹æ”¯æŒçš„ StAX(Streaming API for XML)

**DOM**

åŸºäºæ ‘å½¢ç»“æ„çš„ XML è§£ææ–¹å¼ï¼Œå®ƒä¼šå°†æ•´ä¸ª XML æ–‡æ¡£è¯»å…¥å†…å­˜å¹¶æ„å»ºä¸€ä¸ª DOM æ ‘ï¼ŒåŸºäºè¿™é¢—æ ‘å½¢ç»“æ„å¯¹å„ä¸ªèŠ‚ç‚¹(Node)è¿›è¡Œæ“ä½œã€‚

**SAX**

SAX æ˜¯åŸºäºäº‹ä»¶æ¨¡å‹çš„ XML è§£ææ–¹å¼ï¼Œå®ƒå¹¶ä¸éœ€è¦å°†æ•´ä¸ª XML æ–‡æ¡£åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œè€Œåªéœ€å°† XML æ–‡æ¡£çš„ä¸€éƒ¨åˆ†åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå³å¼€å§‹è§£æ.åœ¨æ»¡è¶³æ¡ä»¶æ—¶ï¼Œä¹Ÿå¯ä»¥ç«‹å³åœæ­¢è§£æè¿‡ç¨‹ï¼Œè¿™æ ·å°±ä¸å¿…è§£æå‰©ä½™çš„ XML å†…å®¹

**StAX**

JAXP æ˜¯ JDK æä¾›çš„ä¸€å¥—ç”¨äºè§£æ XML çš„APIï¼Œå®ƒå¾ˆå¥½åœ°æ”¯æŒ DOM å’Œ SAX è§£ææ–¹å¼ï¼ŒJAXP æ˜¯ JavaSE çš„ä¸€éƒ¨åˆ†ï¼Œå®ƒç”± `javax.xml`ã€`org.w3c.com`ã€`org.xml.sax`åŒ…åŠå…¶å­åŒ…ç»„æˆã€‚ä» JDK 6.0 å¼€å§‹ï¼ŒJAXP å¼€å§‹æ”¯æŒå¦ä¸€ç§ XML è§£ææ–¹å¼ StAX è§£ææ–¹å¼

![image.png](http://ww1.sinaimg.cn/large/006rAlqhgy1gm4omcpnmjj30pa08o3zp.jpg)

> ğŸ¤”çœ‹ä¸å¤ªæ‡‚äº†..

## 2 åå°„å·¥å…·ç®±

MyBatis åœ¨è¿›è¡Œå‚æ•°å¤„ç†ã€ç»“æœæ˜ å°„ç­‰æ“ä½œæ—¶ï¼Œä¼šæ¶‰åŠå¤§é‡çš„åå°„æ“ä½œã€‚MyBatis æä¾›äº†ä¸“é—¨çš„åå°„æ¨¡å—ï¼Œè¯¥æ¨¡å—ä½äº`org.apache.ibatis.reflection`

### 1 Reflector & ReflectorFactory

> Reflector æ˜¯ MyBatis ä¸­åå°„æ¨¡å—çš„åŸºç¡€ï¼Œæ¯ä¸ª Reflector å¯¹è±¡éƒ½å¯¹åº”ä¸€ä¸ªç±»ï¼Œåœ¨ Reflector ä¸­ç¼“å­˜äº†åå°„æ“ä½œéœ€è¦ä½¿ç”¨çš„ç±»çš„å…ƒä¿¡æ¯





## 3 ç±»å‹è½¬æ¢

ä»ç»“æœé›†ä¸­è·å–æ•°æ®æ—¶ï¼Œåˆ™éœ€è¦ä» Java ç±»å‹è½¬æ¢æˆ JDBC ç±»å‹ã€‚MyBatis ä½¿ç”¨ **ç±»å‹å¤„ç†å™¨**å®Œæˆä¸Šè¿°ä¸¤ç§è½¬æ¢

![image.png](http://ww1.sinaimg.cn/large/006rAlqhgy1gm4pcm6zl5j30h00bgmyi.jpg)

### 1 TypeHandler

MyBatis ä¸­æ‰€æœ‰çš„ç±»å‹è½¬æ¢å™¨éƒ½ç»§æ‰¿äº†TypeHandler æ¥å£ï¼Œæ¥å£å››ä¸ªæ–¹æ³•åˆ†ä¸ºä¸¤ç±»:

- setParameter() æ–¹æ³•è´Ÿè´£å°†Java ç±»å‹æ•°æ®è½¬æ¢ä¸ºJdbcç±»å‹
- getResult() æ–¹æ³•å³å…¶é‡è½½è´Ÿè´£å°†ç»“æœé›†æ•°æ®è½¬æ¢ä¸ºJavaç±»å‹

> ~~ğŸ¤”æ€ä¹ˆæ„Ÿè§‰åäº† 2020-12-30 ä»£ç¡®è®¤~~ 
>
> ä»å®ç°ç±»å‘ç°åº”è¯¥æ˜¯ä¹¦ä¸Šå†™åäº†

ä¸ºäº†æ–¹ä¾¿ç”¨æˆ·è‡ªå®šä¹‰ TypeHandler å®ç°ï¼ŒMyBatis æä¾›äº† `BaseTypeHandler` è¿™ä¸ªæŠ½è±¡ç±»ï¼Œå®ƒå®ç°äº† TypeHandler æ¥å£ï¼Œå¹¶ç»§æ‰¿äº† TypeReference æŠ½è±¡ç±»ã€‚BaseTypeHandler çš„å®ç°ç±»æ¯”è¾ƒå¤šï¼Œ**å¤§å¤šæ˜¯ç›´æ¥è°ƒç”¨ PreparedStatement å’Œ ResultSet æˆ– CallableStatement çš„å¯¹åº”æ–¹æ³•**



> ä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒTypeHandler ç”¨äºå®Œæˆå•ä¸ªå‚æ•°ä»¥åŠå•ä¸ªåˆ—å€¼çš„ç±»å‹è½¬æ¢ï¼Œå¦‚æœå­˜åœ¨å¤šåˆ—å€¼è½¬æ¢æˆä¸€ä¸ª Java å¯¹è±¡çš„éœ€æ±‚ï¼Œåº”è¯¥ä¼˜å…ˆè€ƒè™‘ä½¿ç”¨åœ¨æ˜ å°„æ–‡ä»¶ä¸­å®šä¹‰åˆé€‚çš„æ˜ å°„è§„åˆ™(<resultMap>èŠ‚ç‚¹)å®Œæˆæ˜ å°„

### 2 TypeHandlerRegistry

**MyBatis é€šè¿‡ TypeHandlerRegistry  ç®¡ç†ä¼—å¤šçš„ TypeHandler æ¥å£å®ç°**ï¼Œåœ¨ MyBatis åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œä¼šä¸ºæ‰€æœ‰å·²çŸ¥çš„ TypeHandler åˆ›å»ºå¯¹è±¡ï¼Œå¹¶å®ç°æ³¨å†Œåˆ° TypeHandlerRegistry ä¸­ã€‚

```java
public final class TypeHandlerRegistry {
    
    // è®°å½• jdbcType ä¸ TypeHandler ä¹‹é—´çš„å¯¹åº”å…³ç³»ï¼Œå…¶ä¸­ JdbcTypeæ˜¯æšä¸¾ç±»å‹ï¼Œå®ƒå®šä¹‰å¯¹åº”çš„JDBCç±»å‹
    // è¯¥é›†åˆä¸»è¦ä»ç»“æœé›†è¯»å–æ•°æ®æ—¶ï¼Œå°†æ•°æ®ä» Jdbc ç±»å‹è½¬æ¢ä¸º Java ç±»å‹
	private final Map<JdbcType, TypeHandler<?>>  jdbcTypeHandlerMap = new EnumMap<>(JdbcType.class);
    
    // è®°å½•äº† Javaç±»å‹å‘æŒ‡å®š JdbcType è½¬æ¢æ—¶ï¼Œéœ€è¦ä½¿ç”¨çš„ TypeHandler å¯¹è±¡ã€‚
    // è½¬æ¢æˆæ•°æ®åº“çš„ charã€varchar ç­‰å¤šç§ç±»å‹ï¼Œæ‰€ä»¥å­˜åœ¨ä¸€å¯¹å¤šå…³ç³»
  	private final Map<Type, Map<JdbcType, TypeHandler<?>>> typeHandlerMap = new ConcurrentHashMap<>();
    
    // 
  	private final TypeHandler<Object> unknownTypeHandler;
    
    // è®°å½•äº†å…¨éƒ¨ TypeHandler çš„ç±»å‹ä»¥åŠè¯¥ç±»å‹ç›¸åº”çš„ TypeHandler å¯¹è±¡
  	private final Map<Class<?>, TypeHandler<?>> allTypeHandlersMap = new HashMap<>();
	// ç©º TypeHandler é›†åˆçš„æ ‡è¯†
	private static final Map<JdbcType, TypeHandler<?>> NULL_TYPE_HANDLER_MAP = Collections.emptyMap();

 	private Class<? extends TypeHandler> defaultEnumTypeHandler = EnumTypeHandler.class;
}
```

**æ³¨å†Œ TypeHandler å¯¹è±¡**

`TypeHandlerRegistry.register()`æ–¹æ³•å®ç°äº†æ³¨å†Œ `TypeHandler`å¯¹è±¡çš„åŠŸèƒ½ï¼Œè¯¥æ³¨å†Œè¿‡ç¨‹ä¼šå‘ä¸Šè¿°å››ä¸ªé›†åˆæ·»åŠ  `TypeHandler`å¯¹è±¡ã€‚register() æ–¹æ³•æœ‰å¤šä¸ªé‡è½½

![image.png](http://ww1.sinaimg.cn/large/006rAlqhgy1gm5ugzn7apj30qy0cq0ur.jpg)

ä¸€äº› register() æ–¹æ³•ä¸»è¦å®Œæˆå¼ºåˆ¶ç±»å‹è½¬æ¢æˆ–åˆå§‹åŒ– `TypeHandler`çš„åŠŸèƒ½ï¼Œè¿˜æœ‰ä¸€äº›å®ç°æ³¨å†ŒåŠŸèƒ½ã€‚

![image.png](http://ww1.sinaimg.cn/large/006rAlqhgy1gm5uqg9ku1j30qy0ckwh2.jpg)

å¤šæ•° `register()`æ–¹æ³•æœ€ç»ˆä¼šè°ƒç”¨é‡è½½`regsiter(Type,JdbcType,TypeHandler)`å®Œæˆæ³¨å†ŒåŠŸèƒ½ï¼Œæˆ‘ä»¬ä»‹ç»è¯¥æ–¹æ³•çš„å®ç°

```java
  private void register(Type javaType, JdbcType jdbcType, TypeHandler<?> handler) {
      // æ£€æµ‹æ˜¯å¦æ˜ç¡®æŒ‡å®šäº† TypeHandler èƒ½å¤Ÿå¤„ç†çš„ Java ç±»å‹
    if (javaType != null) {
        // è·å–æŒ‡å®š Java ç±»å‹åœ¨ typeHandlerMap é›†åˆä¸­å¯¹åº”çš„ TypeHandler é›†åˆ
      Map<JdbcType, TypeHandler<?>> map = typeHandlerMap.get(javaType);
        
      if (map == null || map == NULL_TYPE_HANDLER_MAP) {
        map = new HashMap<>();
      }
      map.put(jdbcType, handler);
        // åˆ›å»ºæ–°çš„ jdbcTypeHandler é›†åˆï¼Œå¹¶æ·»åŠ åˆ° typehandlermap é›†åˆä¸­
      typeHandlerMap.put(javaType, map);
    }
      // å‘ allTypeHandlerMap é›†åˆæ³¨å†Œ TypeHandler ç±»å‹å’Œå¯¹åº”çš„ TypeHandler å¯¹è±¡
    allTypeHandlersMap.put(handler.getClass(), handler);
  }
```

åœ¨

- `register(Class<?> typeHandlerClass)`
- `register(TypeHandler<T> typeHandler)`
- `register(Type javaType, TypeHandler<? extends T> typeHandler)`

ä¸­ä¼šå°è¯•è¯»å– `TypeHandler`ç±»ä¸­å®šä¹‰çš„`@MappedTypes`æ³¨è§£å’Œ `@MappedJdbcTypes`æ³¨è§£ï¼Œ`@MappedTypes` æ³¨è§£ç”¨äºæŒ‡æ˜è¯¥ `TypeHandler` å®ç°ç±»èƒ½å¤Ÿå¤„ç†çš„ Java ç±»å‹çš„é›†åˆï¼Œ`@MappedJdbcTypes`æ³¨è§£ç”¨äºæŒ‡æ˜è¯¥ `TypeHandler`å®ç°ç±»èƒ½å¤Ÿå¤„ç†çš„ JDBC ç±»å‹é›†åˆã€‚

```java
  public void register(Class<?> typeHandlerClass) {
    boolean mappedTypeFound = false;
      // è·å– @MappedTypes æ³¨è§£
    MappedTypes mappedTypes = typeHandlerClass.getAnnotation(MappedTypes.class);
    if (mappedTypes != null) {
        // æ ¹æ® @MappedTypes æ³¨è§£ä¸­æŒ‡å®šçš„ Java ç±»å‹è¿›è¡Œæ³¨å†Œ
      for (Class<?> javaTypeClass : mappedTypes.value()) {
          // ç»è¿‡å¼ºåˆ¶ç±»å‹è½¬æ¢ä»¥åŠä½¿ç”¨åå°„åˆ›å»º TypeHandler å¯¹è±¡ä¹‹å
        register(javaTypeClass, typeHandlerClass);
        mappedTypeFound = true;
      }
    }
    if (!mappedTypeFound) {
        // æœªæŒ‡å®š @MappedTypes æ³¨è§£ï¼Œäº¤ç”±é‡è½½ register(TypeHandler<T> typeHandler)
      register(getInstance(null, typeHandlerClass));
    }
  }
```

register(TypeHandler<T> typeHandler)

```java
  @SuppressWarnings("unchecked")
  public <T> void register(TypeHandler<T> typeHandler) {
    boolean mappedTypeFound = false;
      // è·å– @MappedTypes æ³¨è§£
    MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class);
    if (mappedTypes != null) {
      for (Class<?> handledType : mappedTypes.value()) {
        register(handledType, typeHandler);
        mappedTypeFound = true;
      }
    }
    // @since 3.1.0 - try to auto-discover the mapped type
    if (!mappedTypeFound && typeHandler instanceof TypeReference) {
      try {
        TypeReference<T> typeReference = (TypeReference<T>) typeHandler;
        register(typeReference.getRawType(), typeHandler);
        mappedTypeFound = true;
      } catch (Throwable t) {
        // maybe users define the TypeReference with a different type and are not assignable, so just ignore it
      }
    }
    if (!mappedTypeFound) {
      register((Class<T>) null, typeHandler);
    }
  }
```

`register(Type javaType, TypeHandler<? extends T> typeHandler)`

```java
  private <T> void register(Type javaType, TypeHandler<? extends T> typeHandler) {
      // è·å– @MappedTypes æ³¨è§£
    MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);
    if (mappedJdbcTypes != null) {
      for (JdbcType handledJdbcType : mappedJdbcTypes.value()) {
        register(javaType, handledJdbcType, typeHandler);
      }
      if (mappedJdbcTypes.includeNullJdbcType()) {
        register(javaType, null, typeHandler);
      }
    } else {
      register(javaType, null, typeHandler);
    }
  }
```

ä¸Šè¿°ä¸‰ä¸ªæ–¹æ³•é‡è½½éƒ½æ˜¯å‘ typeHandlerMap é›†åˆå’Œ allTypeHandlersMap é›†åˆæ³¨å†ŒTypeHandler å¯¹è±¡ã€‚ è€Œ`register(JdbcType jdbcType, TypeHandler<?> handler)`æ˜¯å‘ jdbcTypeHandlerMap é›†åˆæ³¨å†Œ TypeHandler å¯¹è±¡

```java
  public void register(JdbcType jdbcType, TypeHandler<?> handler) {
      // æ³¨å†Œ JDBC ç±»å‹å¯¹åº”çš„ TypeHandler
    jdbcTypeHandlerMap.put(jdbcType, handler);
  }
```

TypeHandlerRegister é™¤äº†æä¾›æ³¨å†Œå•ä¸ª `TypeHandler`çš„ register() é‡è½½ï¼Œè¿˜å¯ä»¥æ‰«ææ•´ä¸ªåŒ…ä¸‹çš„ `TypeHandler`æ¥å£çš„å®ç°ç±»ï¼Œå¹¶å°†å®Œæˆè¿™äº› TypeHandler å®ç°ç±»çš„æ³¨å†Œ

```java
  public void register(String packageName) {
    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();
      // æŸ¥æ‰¾æŒ‡å®šåŒ…ä¸‹çš„ TypeHandler æ¥å£å®ç°ç±»
    resolverUtil.find(new ResolverUtil.IsA(TypeHandler.class), packageName);
    Set<Class<? extends Class<?>>> handlerSet = resolverUtil.getClasses();
    for (Class<?> type : handlerSet) {
      //Ignore inner classes and interfaces (including package-info.java) and abstract classes
        // è¿‡æ»¤æ‰å†…éƒ¨ç±»ã€æ¥å£ä»¥åŠæŠ½è±¡ç±»
      if (!type.isAnonymousClass() && !type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {
          // 
        register(type);
      }
    }
  }
```

æœ€åæ„é€ æ–¹æ³•ä¸ºè®¸å¤šç±»å‹è¿›è¡Œæ³¨å†Œ

**2 æŸ¥æ‰¾TypeHandler**

ä»‹ç»å®Œæ³¨å†Œ `TypeHandler`å¯¹è±¡çš„åŠŸèƒ½ä¹‹åï¼Œå†æ¥ä»‹ç»`TypeHandlerRegistery`æä¾›çš„ **æŸ¥æ‰¾ TypeHandler å¯¹è±¡**çš„åŠŸèƒ½ã€‚ `TypeHandlerRegistry.getTypeHandler()` æ–¹æ³•å®ç°äº†ä»ä¸Šè¿°å››ä¸ªé›†åˆä¸­è·å–å¯¹åº” TypeHandler å¯¹è±¡çš„åŠŸèƒ½ã€‚

![image.png](http://ww1.sinaimg.cn/large/006rAlqhgy1gm5wf03nclj30qs0a0mz5.jpg)

å°±è¿‡ä¸€ç³»åˆ—çš„è½¬æ¢ä¹‹åï¼Œ`TypeHandlerRegistry.getTypeHandler()`æ–¹æ³•çš„å¤šä¸ªé‡è½½éƒ½ä¼šè°ƒç”¨`getTypeHandler(Type type, JdbcType jdbcType)`

```java
  @SuppressWarnings("unchecked")
  private <T> TypeHandler<T> getTypeHandler(Type type, JdbcType jdbcType) {
       
    if (ParamMap.class.equals(type)) {
      return null;
    }
      // æŸ¥æ‰¾ Java ç±»å‹å¯¹åº”çš„ TypeHandler é›†åˆ
    Map<JdbcType, TypeHandler<?>> jdbcHandlerMap = getJdbcHandlerMap(type);
    TypeHandler<?> handler = null;
    if (jdbcHandlerMap != null) {
        // æ ¹æ® JdbcType ç±»å‹æŸ¥æ‰¾ TypeHandler å¯¹è±¡
      handler = jdbcHandlerMap.get(jdbcType);
      if (handler == null) {
        handler = jdbcHandlerMap.get(null);
      }
      if (handler == null) {
        // # 591
          // å¦‚æœ JdbcHandlerMap åªæ³¨å†Œäº†ä¸€ä¸ª TypeHandlerï¼Œåˆ™ä½¿ç”¨æ­¤ TypeHandler å¯¹è±¡
        handler = pickSoleHandler(jdbcHandlerMap);
      }
    }
    // type drives generics here
    return (TypeHandler<T>) handler;
  }
```

åœ¨ `TypeHandlerRegistry.getJdbcHandlerMap()` æ–¹æ³•ä¸­ï¼Œä¼šæ£€æµ‹ type_handler_map é›†åˆä¸­æŒ‡å®š Java ç±»å‹å¯¹åº”çš„ `TypeHandler`é›†åˆæ˜¯å¦å·²ç»åˆå§‹åŒ–ã€‚å¦‚æœæœªåˆå§‹åŒ–ï¼Œåˆ™å°è¯•ä»¥è¯¥ Java ç±»å‹çš„ã€å·²åˆå§‹åŒ–çš„çˆ¶ç±»å¯¹åº”çš„ TypeHandler é›†åˆä¸ºåˆå§‹åŒ–é›†åˆï¼›å¦‚ä¸å­˜åœ¨å·²åˆå§‹åŒ–çš„çˆ¶ç±»ï¼Œåˆ™å°†å…¶å¯¹åº”çš„ TypeHandler é›†åˆåˆå§‹åŒ–ä¸º null_type_handler_map æ ‡è¯†ã€‚

```java
  private Map<JdbcType, TypeHandler<?>> getJdbcHandlerMap(Type type) {
    // æŸ¥æ‰¾æŒ‡å®š Java ç±»å‹å¯¹åº”çš„ TypeHandler é›†åˆ
    Map<JdbcType, TypeHandler<?>> jdbcHandlerMap = typeHandlerMap.get(type);
      // æ£€æµ‹æ˜¯å¦ä¸ºç©ºé›†åˆæ ‡è¯†
    if (NULL_TYPE_HANDLER_MAP.equals(jdbcHandlerMap)) {
      return null;
    }
      // åˆå§‹åŒ–Javaç±»å‹çš„ TypeHandler é›†åˆ
    if (jdbcHandlerMap == null && type instanceof Class) {
      Class<?> clazz = (Class<?>) type;
      if (Enum.class.isAssignableFrom(clazz)) {
        Class<?> enumClass = clazz.isAnonymousClass() ? clazz.getSuperclass() : clazz;
          // æŸ¥æ‰¾çˆ¶ç±»å¯¹åº” çš„ TypeHandler é›†åˆï¼Œå¹¶ä½œä¸ºåˆå§‹é›†åˆ
        jdbcHandlerMap = getJdbcHandlerMapForEnumInterfaces(enumClass, enumClass);
        if (jdbcHandlerMap == null) {
          register(enumClass, getInstance(enumClass, defaultEnumTypeHandler));
          return typeHandlerMap.get(enumClass);
        }
      } else {
        jdbcHandlerMap = getJdbcHandlerMapForSuperclass(clazz);
      }
    }
    typeHandlerMap.put(type, jdbcHandlerMap == null ? NULL_TYPE_HANDLER_MAP : jdbcHandlerMap);
    return jdbcHandlerMap;
  }
```

- `TypeHandlerRegistry.getMappingTypeHandler()`æ–¹æ³•ä¼šæ ¹æ®æŒ‡å®šçš„ `TypeHandler`ç±»å‹ï¼Œç›´æ¥ä» `ALL_TYPE_HANDLERS_MAP`é›†åˆä¸­æŸ¥æ‰¾å¯¹è±¡
- `TypeHandlerRegistry.getTypeHandler(JdbcType)`ç›´æ¥ä» `JDBC_TYPE_HANDLER_MAP`é›†åˆä¸­æŸ¥æ‰¾ `TypeHandler`å¯¹è±¡

> MyBatis æœ¬èº«æä¾› TypeHandler å®ç°ï¼Œä¹Ÿå¯ä»¥æ·»åŠ è‡ªå®šä¹‰çš„ TypeHandleræ¥å£å®ç°ï¼Œæ·»åŠ ç›¸åº”çš„ `<typeHandler>`èŠ‚ç‚¹é…ç½®ï¼Œå¹¶åˆ¶å®šè‡ªå®šä¹‰çš„`TypeHandler`ç±»å‹çš„å¯¹è±¡æ³¨å†Œåˆ°`TypeHandlerRegistry`ä¸­ï¼Œä¾› MyBatis åç»­ä½¿ç”¨

### 3 TypeAliasRegistry

åœ¨ç¼–å†™ SQL è¯­å¥æ—¶ï¼Œä½¿ç”¨åˆ«åå¯ä»¥æ–¹ä¾¿ç†è§£ä»¥åŠç»´æŠ¤ã€‚MyBatis é€šè¿‡ TypeAliasRegistry ç±»å®Œæˆåˆ«åæ³¨å†Œå’Œç®¡ç†çš„åŠŸèƒ½ï¼ŒTypeAliasRegistry çš„ç»“æ„æ¯”è¾ƒç®€å•ï¼Œå®ƒé€šè¿‡`TYPE_ALIASES`å­—æ®µ(`Map<String,Class<?>>`)ç®¡ç†åˆ«åä¸ Java ç±»å‹ä¹‹é—´çš„å¯¹åº”å…³ç³»ï¼Œé€šè¿‡ `TypeAliasRegistry.registerAlias()`æ–¹æ³•å®Œæˆæ³¨å†Œåˆ«åï¼Œè¯¥æ–¹æ³•çš„å…·ä½“å®ç°å¦‚ä¸‹ï¼š

```java
  public void registerAlias(String alias, Class<?> value) {
    if (alias == null) {
      throw new TypeException("The parameter alias cannot be null");
    }
    // issue #748 æ£€æµ‹æ˜¯å¦å·²ç»å­˜åœ¨
    String key = alias.toLowerCase(Locale.ENGLISH);
    if (typeAliases.containsKey(key) && typeAliases.get(key) != null && !typeAliases.get(key).equals(value)) {
      throw new TypeException("The alias '" + alias + "' is already mapped to the value '" + typeAliases.get(key).getName() + "'.");
    }
      // æ³¨å†Œåˆ«å
    typeAliases.put(key, value);
  }
```

åœ¨`TypeAliasRegistry`çš„æ„é€ æ–¹æ³•ä¸­ï¼Œ

- é»˜è®¤ä¸ºJavaçš„åŸºæœ¬ç±»å‹åŠå…¶æ•°ç»„ç±»å‹
- åŸºæœ¬ç±»å‹çš„å°è£…ç±»åŠå…¶æ•°ç»„ç±»å‹
- Date
- BigDecimal,BigInteger
- Map,HashMap
- ....





```java
  public TypeAliasRegistry() {
    registerAlias("string", String.class);

    registerAlias("byte", Byte.class);
    registerAlias("long", Long.class);
    registerAlias("short", Short.class);
    registerAlias("int", Integer.class);
    registerAlias("integer", Integer.class);
    registerAlias("double", Double.class);
    registerAlias("float", Float.class);
    registerAlias("boolean", Boolean.class);

    registerAlias("byte[]", Byte[].class);
    registerAlias("long[]", Long[].class);
    registerAlias("short[]", Short[].class);
    registerAlias("int[]", Integer[].class);
    registerAlias("integer[]", Integer[].class);
    registerAlias("double[]", Double[].class);
    registerAlias("float[]", Float[].class);
    registerAlias("boolean[]", Boolean[].class);

    registerAlias("_byte", byte.class);
    registerAlias("_long", long.class);
    registerAlias("_short", short.class);
    registerAlias("_int", int.class);
    registerAlias("_integer", int.class);
    registerAlias("_double", double.class);
    registerAlias("_float", float.class);
    registerAlias("_boolean", boolean.class);

    registerAlias("_byte[]", byte[].class);
    registerAlias("_long[]", long[].class);
    registerAlias("_short[]", short[].class);
    registerAlias("_int[]", int[].class);
    registerAlias("_integer[]", int[].class);
    registerAlias("_double[]", double[].class);
    registerAlias("_float[]", float[].class);
    registerAlias("_boolean[]", boolean[].class);

    registerAlias("date", Date.class);
    registerAlias("decimal", BigDecimal.class);
    registerAlias("bigdecimal", BigDecimal.class);
    registerAlias("biginteger", BigInteger.class);
    registerAlias("object", Object.class);

    registerAlias("date[]", Date[].class);
    registerAlias("decimal[]", BigDecimal[].class);
    registerAlias("bigdecimal[]", BigDecimal[].class);
    registerAlias("biginteger[]", BigInteger[].class);
    registerAlias("object[]", Object[].class);

    registerAlias("map", Map.class);
    registerAlias("hashmap", HashMap.class);
    registerAlias("list", List.class);
    registerAlias("arraylist", ArrayList.class);
    registerAlias("collection", Collection.class);
    registerAlias("iterator", Iterator.class);

    registerAlias("ResultSet", ResultSet.class);
  }
```

- `registerAliases(String,Class<?>)`ä¼šæ‰«æç½®é¡¶åŒ…ä¸‹æ‰€æœ‰çš„ç±»
- `registerAlias(Class<?>)`ä¼šå°è¯•è¯»å–`@Alias`æ³¨è§£

```java
  public void registerAliases(String packageName, Class<?> superType) {
    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<>();
    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);
    Set<Class<? extends Class<?>>> typeSet = resolverUtil.getClasses();
    for (Class<?> type : typeSet) {
      // Ignore inner classes and interfaces (including package-info.java)
      // Skip also inner classes. See issue #6
      if (!type.isAnonymousClass() && !type.isInterface() && !type.isMemberClass()) {
        registerAlias(type);
      }
    }
  }

  public void registerAlias(Class<?> type) {
    String alias = type.getSimpleName();
    Alias aliasAnnotation = type.getAnnotation(Alias.class);
    if (aliasAnnotation != null) {
      alias = aliasAnnotation.value();
    }
    registerAlias(alias, type);
  }
```

## 4 æ—¥å¿—æ¨¡å—

æ—¥å¿—æ˜¯å¼€å‘ä¸è¿ç»´ç®¡ç†ä¹‹é—´çš„æ¡¥æ¢ã€‚æ—¥å¿—å¯ä»¥å¸®åŠ©è¿ç»´äººå‘˜å’Œç®¡ç†äººå‘˜å¿«é€ŸæŸ¥æ‰¾ç³»ç»Ÿçš„æ•…éšœå’Œç“¶é¢ˆã€‚æ—¥å¿—ä¿¡æ¯é‡ä¼šéšç€è½¯ä»¶è¿è¡Œæ—¶é—´ä¸æ–­å˜å¤šï¼Œæ‰€ä»¥éœ€è¦å®šæœŸæ±‡æ€»å’Œæ¸…ç†ï¼Œé¿å…å½±å“æœåŠ¡å™¨çš„æ­£å¸¸è¿è¡Œã€‚

Java å¼€å‘ä¸­å¸¸ç”¨çš„æ—¥å¿—æ¡†æ¶æœ‰ Log4jã€Log4j2ã€Apache Commons Logã€java.loggingã€slf4jç­‰ã€‚**ä¸ºäº†ç»Ÿä¸€è¿™äº›å·¥å…·çš„æ¥å£ï¼ŒMyBatis å®šä¹‰äº†ä¸€å¥—ç»Ÿä¸€çš„æ—¥å¿—æ¥å£ä¾›ä¸Šå±‚ä½¿ç”¨ï¼Œå¹¶ä¸ºä¸Šè¿°å¸¸ç”¨çš„æ—¥å¿—æ¡†æ¶æä¾›ç›¸åº”çš„é€‚é…å™¨**

### 1 é€‚é…å™¨æ¨¡å¼

ç®€å•ä»‹ç»è®¾è®¡æ¨¡å¼ä¸­å…­å¤§åŸåˆ™

- å•ä¸€èŒè´£åŸåˆ™:ä¸è¦å­˜åœ¨å¤šäºä¸€ä¸ªå¯¼è‡´å˜æ›´çš„å…ƒå©´ï¼Œç®€å•æ¥è¯´ï¼Œä¸€ä¸ªç±»ä¸­åªè´Ÿè´£å”¯ä¸€é¡¹èŒè´£
- é‡Œæ°æ›¿æ¢åŸåˆ™:å¦‚æœå¯¹æ¯ä¸€ä¸ªç±»å‹ä¸ºT1çš„å¯¹è±¡t1ï¼Œéƒ½æœ‰ç±»å‹ä¸ºT2çš„å¯¹è±¡
	t2ï¼Œä½¿å¾—ä»¥T1å®šä¹‰çš„æ‰€æœ‰ç¨‹åºPåœ¨æ‰€æœ‰çš„å¯¹è±¡t1éƒ½ä»£æ¢æˆt2æ—¶ï¼Œç¨‹åºPçš„
	è¡Œä¸ºæ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œé‚£ä¹ˆç±»å‹T2æ˜¯ç±»å‹T1çš„å­ç±»å‹ã€‚éµå®ˆé‡Œæ°æ›¿æ¢åŸ
	åˆ™ï¼Œå¯ä»¥å¸®åŠ©æˆ‘ä»¬è®¾è®¡å‡ºæ›´ä¸ºåˆç†çš„ç»§æ‰¿ä½“ç³»ã€‚
- ä¾èµ–å€’ç½®åŸåˆ™:ç³»ç»Ÿçš„é«˜å±‚æ¨¡å—ä¸åº”è¯¥ä¾èµ–ä½å±‚æ¨¡å—çš„å…·ä½“å®ç°ï¼ŒäºŒè€…
	éƒ½åº”è¯¥ä¾èµ–å…¶æŠ½è±¡ç±»æˆ–æ¥å£ï¼ŒæŠ½è±¡æ¥å£ä¸åº”è¯¥ä¾èµ–å…·ä½“å®ç°ç±»ï¼Œè€Œå…·ä½“å®
	ç°ç±»åº”è¯¥äºä¾èµ–æŠ½è±¡ã€‚ç®€å•æ¥è¯´ï¼Œ**æˆ‘ä»¬è¦é¢å‘æ¥å£ç¼–ç¨‹ã€‚å½“éœ€æ±‚å‘ç”Ÿå˜åŒ–
	æ—¶å¯¹å¤–æ¥å£ä¸å˜ï¼Œåªè¦æä¾›æ–°çš„å®ç°ç±»å³å¯ã€‚**
- æ¥å£éš”ç¦»åŸåˆ™:ä¸€ä¸ªç±»å¯¹å¦ä¸€ä¸ªç±»çš„ä¾èµ–åº”è¯¥å»ºç«‹åœ¨æœ€å°çš„æ¥å£ä¸Šã€‚ç®€
	å•æ¥è¯´ï¼Œæˆ‘ä»¬åœ¨è®¾è®¡æ¥å£æ—¶ï¼Œä¸è¦è®¾è®¡å‡ºåºå¤§è‡ƒè‚¿çš„æ¥å£ï¼Œå› ä¸ºå®ç°è¿™ç§
	æ¥å£æ—¶éœ€è¦å®ç°å¾ˆå¤šä¸å¿…è¦çš„æ–¹æ³•ã€‚æˆ‘ä»¬è¦**å°½é‡è®¾è®¡å‡ºåŠŸèƒ½å•ä¸€çš„æ¥å£ï¼Œ
	è¿™æ ·ä¹Ÿèƒ½ä¿è¯å®ç°ç±»çš„èŒè´£å•ä¸€ã€‚**
- è¿ªç±³ç‰¹æ³•åˆ™:ä¸€ä¸ªå¯¹è±¡åº”è¯¥å¯¹å…¶ä»–å¯¹è±¡ä¿æŒæœ€å°‘çš„äº†è§£ã€‚ç®€å•æ¥è¯´ï¼Œå°±
	æ˜¯**è¦æ±‚æˆ‘ä»¬å‡ä½ç±»é—´è€¦åˆ**ã€‚
- å¼€æ”¾-å°é—­åŸåˆ™:**ç¨‹åºè¦å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­**ã€‚ç®€å•æ¥è¯´ï¼Œå½“éœ€æ±‚
	å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æ·»åŠ æ–°çš„æ¨¡å—æ»¡è¶³æ–°éœ€æ±‚ï¼Œè€Œä¸æ˜¯é€šè¿‡ä¿®æ”¹åŸ
	æ¥çš„å®ç°ä»£ç æ¥æ»¡è¶³æ–°éœ€æ±‚ã€‚

**åœ¨è¿™å…­æ¡åŸåˆ™ä¸­ï¼Œå¼€æ”¾-å°é—­åŸåˆ™æ˜¯æœ€åŸºç¡€çš„åŸåˆ™ï¼Œä¹Ÿæ˜¯å…¶ä»–åŸåˆ™ä»¥åŠå
æ–‡ä»‹ç»çš„æ‰€æœ‰è®¾è®¡æ¨¡å¼çš„æœ€ç»ˆç›®æ ‡ã€‚**

> é€‚é…å™¨æ¨¡å¼çš„ä¸»è¦ç›®çš„æ˜¯è§£å†³ç”±äºæ¥å£ä¸èƒ½å…¼å®¹è€Œå¯¼è‡´ç±»æ— æ³•ä½¿ç”¨çš„é—®é¢˜ï¼Œé€‚é…å™¨æ¨¡å¼ä¼šå°†éœ€è¦é€‚é…çš„ç±»è½¬æ¢æˆè°ƒç”¨è€…èƒ½å¤Ÿä½¿ç”¨çš„ç›®æ ‡æ¥å£ã€‚é€‚é…å™¨æ¨¡å¼ä¸­æ¶‰åŠçš„å‡ ä¸ªè§’è‰²ï¼š
>
> - ç›®æ ‡æ¥å£(Target): è°ƒç”¨è€…èƒ½å¤Ÿç›´æ¥ä½¿ç”¨çš„æ¥å£
> - éœ€è¦é€‚é…çš„ç±»(Adptee)ï¼šä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒAdaptee ç±»ä¸­æœ‰çœŸæ­£çš„ä¸šåŠ¡é€»è¾‘ï¼Œä½†æ˜¯å…¶æ¥å£ä¸èƒ½è¢«è°ƒç”¨è€…ç›´æ¥ä½¿ç”¨
> - é€‚é…å™¨(Adapter):Adapter å®ç°äº† Target æ¥å£ï¼Œå¹¶åŒ…è£…äº†ä¸€ä¸ª Adaptee å¯¹è±¡ã€‚Adapter åœ¨å®ç° Target æ¥å£ä¸­çš„æ–¹æ³•æ—¶ï¼Œä¼šå°†è°ƒç”¨å§”æ‰˜ç»™ Adaptee å¯¹è±¡çš„ç›¸å…³æ–¹æ³•ï¼Œç”± Adaptee å®Œæˆå…·ä½“çš„ä¸šåŠ¡

![image.png](http://ww1.sinaimg.cn/large/006rAlqhgy1gmbnr8jmgpj30b408cq46.jpg)

é€‚é…å™¨æ¨¡å¼é€šè¿‡æä¾› Adapter çš„æ–¹å¼å®Œæˆæ¥å£é€‚é…ï¼Œå®ç°äº†ç¨‹åºå¤ç”¨ Adaptee çš„éœ€æ±‚ï¼Œé¿å…äº†ä¿®æ”¹ Adaptee å®ç°æ¥å£ï¼Œè¿™ç¬¦åˆ`å¼€å‘-å°é—­`åŸåˆ™.**å½“æœ‰æ–°çš„ Adaptee éœ€è¦è¢«å¤ç”¨æ—¶ï¼Œåªè¦æ·»åŠ æ–°çš„ Adapter å³å¯**

**åœ¨ MyBatis çš„æ—¥å¿—æ¨¡å—ä¸­ï¼Œä½¿ç”¨äº†é€‚é…å™¨æ¨¡å¼** ã€‚MyBatiså†…éƒ¨è°ƒç”¨æ—¥å¿—æ¨¡å—æ—¶ï¼Œä½¿ç”¨äº†å…¶å†…éƒ¨æ¥å£(`org.apache.ibatis.logging.Log`)ã€‚Mybatis ä¸ºäº†é›†æˆå’Œå¤ç”¨è¿™äº›ç¬¬ä¸‰æ–¹æ—¥å¿—ç»„ä»¶ï¼Œåœ¨å…¶æ—¥å¿—æ¨¡å—ä¸­æä¾›äº†å¤šç§ Adapterï¼Œå°†è¿™äº›ç¬¬ä¸‰æ–¹æ—¥å¿—ç»„ä»¶å¯¹å¤–çš„æ¥å£é€‚é…æˆäº†`org.apache.ibatis.logging.Log`,è¿™æ · MyBatis å†…éƒ¨å°±å¯ä»¥ç»Ÿä¸€é€šè¿‡`org.apache.ibatis.logging.Log`æ¥å£è°ƒç”¨ç¬¬ä¸‰æ–¹æ—¥å¿—ç»„ä»¶çš„åŠŸèƒ½äº†ã€‚

### 2 æ—¥å¿—é€‚é…å™¨

MyBayis çš„æ—¥å¿—æ¨¡å—ä½äº `org.apache.ibatis.logging`åŒ…ä¸­ï¼Œè¯¥æ¨¡å—ä¸­é€šè¿‡ Log æ¥å£å®šä¹‰äº†æ—¥å¿—æ¨¡å—çš„åŠŸèƒ½ï¼Œå½“ç„¶æ—¥å¿—é€‚é…å™¨ä¼šå®ç°æ­¤æ¥å£ã€‚**LogFactory å·¥å‚ç±»è´Ÿè´£åˆ›å»ºå¯¹åº”çš„æ—¥å¿—ç»„ä»¶é€‚é…å™¨**

![image.png](http://ww1.sinaimg.cn/large/006rAlqhgy1gmbolklatmj30ka11wn06.jpg)

åœ¨`LogFactory`ç±»åŠ è½½æ—¶ä¼šæ‰§è¡Œå…¶é™æ€ä»£ç å—ï¼Œå…¶é€»è¾‘æ˜¯æŒ‰åºåŠ è½½å¹¶å®ä¾‹åŒ–å¯¹åº”æ—¥å¿—ç»„ä»¶çš„é€‚é…å™¨ï¼Œç„¶åä½¿ç”¨`LogFactory.logConstructor`è¿™ä¸ªé™æ€å­—æ®µï¼Œè®°å½•å½“å‰ä½¿ç”¨çš„ç¬¬ä¸‰æ–¹æ—¥å¿—ç»„ä»¶çš„é€‚é…å™¨

```java
// è®°å½•å½“å‰ä½¿ç”¨çš„ç¬¬ä¸‰æ–¹æ—¥å¿—ç»„ä»¶æ‰€å¯¹åº”çš„é€‚é…å™¨æ„é€ æ–¹æ³•
private static Constructor<? extends Log> logConstructor;
// å°è¯•åŠ è½½å®ç°ç±»
  static {
    tryImplementation(LogFactory::useSlf4jLogging);
    tryImplementation(LogFactory::useCommonsLogging);
    tryImplementation(LogFactory::useLog4J2Logging);
    tryImplementation(LogFactory::useLog4JLogging);
    tryImplementation(LogFactory::useJdkLogging);
    tryImplementation(LogFactory::useNoLogging);
  }
// 
  private static void tryImplementation(Runnable runnable) {
    if (logConstructor == null) {
      try {
        runnable.run();
      } catch (Throwable t) {
        // ignore
      }
    }
  }

// 
  private static void setImplementation(Class<? extends Log> implClass) {
    try {
        // è·å–æŒ‡å®šé€‚é…å™¨çš„æ„é€ æ–¹æ³•
      Constructor<? extends Log> candidate = implClass.getConstructor(String.class);
        // å®ä¾‹åŒ–é€‚é…å™¨
      Log log = candidate.newInstance(LogFactory.class.getName());
        // ...è¾“å‡ºæ—¥å¿—
      if (log.isDebugEnabled()) {
        log.debug("Logging initialized using '" + implClass + "' adapter.");
      }
      logConstructor = candidate;
    } catch (Throwable t) {
      throw new LogException("Error setting Log implementation.  Cause: " + t, t);
    }
  }
```

Jdk14LoggingImpl æ˜¯ä¸‹äº† Log æ¥å£ï¼Œå¹¶å°è£…äº†`java.util.logging.Logger`å¯¹è±¡ï¼Œ`org.appache.ibatis.logging.Log`æ¥å£çš„åŠŸèƒ½å…¨éƒ¨é€šè¿‡è°ƒç”¨`java.util.logging.Logger`å¯¹è±¡å®ç°ï¼Œè¿™ä¸å‰é¢ä»‹ç»çš„é€‚é…å™¨æ¨¡å¼å®Œå…¨ä¸€è‡´

```java
public class Jdk14LoggingImpl implements Log {
 // åº•å±‚å°è£…çš„ java.util.logging.Logger å¯¹è±¡
  private final Logger log;

  public Jdk14LoggingImpl(String clazz) {
      // Logger åº•å±‚å°è£…çš„ java.util.logging.Logger
    log = Logger.getLogger(clazz);
  }

  @Override
  public boolean isDebugEnabled() {
    return log.isLoggable(Level.FINE);
  }

  @Override
  public boolean isTraceEnabled() {
    return log.isLoggable(Level.FINER);
  }

  @Override
  public void error(String s, Throwable e) {
    log.log(Level.SEVERE, s, e);
  }

  @Override
  public void error(String s) {
    log.log(Level.SEVERE, s);
  }

  @Override
  public void debug(String s) {
    log.log(Level.FINE, s);
  }

  @Override
  public void trace(String s) {
    log.log(Level.FINER, s);
  }

  @Override
  public void warn(String s) {
    log.log(Level.WARNING, s);
  }

}
```

### 3 ä»£ç†æ¨¡å¼ä¸ JDK åŠ¨æ€ä»£ç†

![image.png](http://ww1.sinaimg.cn/large/006rAlqhgy1gmbpi65zpxj30rg0bwdjb.jpg)

å…¶ä¸­ Subject æ˜¯ç¨‹åºä¸­çš„ä¸šåŠ¡é€»è¾‘æ¥å£ï¼ŒRealSubject æ˜¯å®ç°äº† `Subject`æ¥å£çš„çœŸæ­£ä¸šåŠ¡ç±»ï¼Œ`Proxy æ˜¯å®ç°äº† Subject æ¥å£çš„ä»£ç†ç±»ï¼Œå…¶ä¸­å°è£…äº† RealSubjectå¯¹è±¡` **åœ¨ç¨‹åºä¸­ä¸ä¼šç›´æ¥è°ƒç”¨ RealSubject å¯¹è±¡çš„æ–¹æ³•ï¼Œè€Œæ˜¯ä½¿ç”¨ Proxy å¯¹è±¡å®ç°ç›¸å…³åŠŸèƒ½ã€‚** `Proxy.operation()` æ–¹æ³•çš„å®ç°ä¼šè°ƒç”¨ `RealSubjectçš„ operation()`æ–¹æ³•æ‰§è¡ŒçœŸæ­£çš„ä¸šåŠ¡é€»è¾‘ï¼Œä½†æ˜¯å¤„ç†å®Œä¸šåŠ¡é€»è¾‘ï¼Œ`Proxy.operation()`ä¼šåœ¨ `RealSubject.operation()`æ–¹æ³•**è°ƒç”¨å‰åè¿›è¡Œé¢„å¤„ç†å’Œç›¸å…³çš„åç½®å¤„ç†**ã€‚è¿™å°±æ˜¯æ‰€è°“çš„ä»£ç†æ¨¡å¼ã€‚

ä¹Ÿå¯ä»¥ä½¿ç”¨ JDK åŠ¨æ€ä»£ç†è§£å†³è¿™ä¸ªé—®é¢˜ã€‚JDK åŠ¨æ€ä»£ç†çš„æ ¸å¿ƒæ˜¯ `InvocationHandler`æ¥å£ã€‚è¿™é‡Œæä¾›ä¸€ä¸ª `InvocationHandler`çš„ç¤ºä¾‹å®ç°ï¼š

```java
public class TestInvokerHandler implements InvocationHandler{
    // çœŸæ­£çš„ä¸šåŠ¡å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯ RealSubject å¯¹è±¡
    private Object target;
    // æ„é€ æ–¹æ³•
    public TestInvokerHandler(Object target){
        this.target = target
    }
    
    public Object invoke(Object proxy,Method method,Object[] args) throws Throwable
    {
        // ... åœ¨æ‰§è¡Œä¸šåŠ¡æ–¹æ³•ä¹‹å‰çš„é¢„å¤„ç†...
        Object result = method.invoke(target,args);
        // ... åœ¨æ‰§è¡Œä¸šåŠ¡æ–¹æ³•ä¹‹åçš„åç½®å¤„ç†...
        return result;
    }
    
    public Object getProxy() {
        //åˆ›å»ºä»£ç†å¯¹è±¡
        return Proxy.newProxyInstance (Thread.currentThread().getContextClassLoader()ï¼Œ
                                         target.getClass().getInterfaces(),this) ;
    }
    // ç”±äºç¯‡å¹…é™åˆ¶ï¼Œmain()æ–¹æ³•ä¸å†å•ç‹¬å†™åœ¨å¦ä¸€ä¸ªç±»ä¸­
    public static void main (String[] args) {
        Subject subject = new RealSubject() ;
        TestInvokerHandler invokerHandler = new TestInvokerHandler (subject) ;
        // è·å–ä»£ç†å¯¹è±¡
        Subject proxy = (Subject) invokerHandler.getProxy();
        // è°ƒç”¨ä»£ç†å¯¹è±¡çš„æ–¹æ³•ï¼Œå®ƒä¼šè°ƒç”¨Test InvokerHandler. invoke()æ–¹æ³•
        proxy.operation();
    }
}
```

åœ¨ç¨‹åºè¿è¡Œæ—¶ï¼ŒJDK ä¼šä¸ºæ¯ä¸ª `RealSubject`ç±»åŠ¨æ€ç”Ÿæˆä»£ç†ç±»å¹¶åŠ è½½åˆ°è™šæ‹Ÿæœºä¸­ï¼Œä¹‹ååˆ›å»ºå¯¹åº”çš„ä»£ç†å¯¹è±¡ã€‚

JDKåŠ¨æ€ä»£ç†ç›¸å…³å®ç°çš„å…¥å£æ˜¯ `Proxy.newProxyInstance()`è¿™ä¸ªé™æ€æ–¹æ³•ï¼Œå®ƒçš„ä¸‰ä¸ªå‚æ•°åˆ†åˆ«æ˜¯åŠ è½½åŠ¨æ€ç”Ÿæˆçš„ **ä»£ç†ç±»åŠ è½½å™¨ã€ä¸šåŠ¡ç±»å®ç°çš„æ¥å£ã€ä¸Šé¢ä»‹ç»çš„ InvocationHandler å¯¹è±¡**ï¼Œä»£ç (JDK1.8)å¦‚ä¸‹

```java
public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        Objects.requireNonNull(h);
	
        final Class<?>[] intfs = interfaces.clone();
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * Look up or generate the designated proxy class.
         * è·å–ä»£ç†ç±»
         */
        Class<?> cl = getProxyClass0(loader, intfs);

        /*
         * Invoke its constructor with the designated invocation handler.
         * 
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }
			// è·å–ä»£ç†ç±»çš„æ„é€ æ–¹æ³•
            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            // åˆ›å»ºä»£ç†å¯¹è±¡
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }

    /**
     * Generate a proxy class.  Must call the checkProxyAccess method
     * to perform permission checks before calling this.
     h
     */
    private static Class<?> getProxyClass0(ClassLoader loader,
                                           Class<?>... interfaces) {
        if (interfaces.length > 65535) {
            throw new IllegalArgumentException("interface limit exceeded");
        }

        // å¦‚æœæŒ‡å®šçš„ç±»åŠ è½½å™¨ä¸­å·²ç»åˆ›å»ºäº†å®ç°æŒ‡å®šæ¥å£çš„ä»£ç†ç±»ï¼Œåˆ™æŸ¥æ‰¾ç¼“å­˜
        // å¦åˆ™é€šè¿‡ ProxyClassFactory åˆ›å»ºå®ç°æŒ‡å®šæ¥å£çš„ä»£ç†ç±»
        return proxyClassCache.get(loader, interfaces);
    }
```

`WeakCache.get()`æ–¹æ³•ä¼šé¦–å…ˆå°è¯•ä»ç¼“å­˜ä¸­æŸ¥æ‰¾ä»£ç†ç±»ï¼Œå¦‚æœæŸ¥æ‰¾ä¸åˆ°ï¼Œåˆ™ä¼šåˆ›å»º Factory å¯¹è±¡å¹¶è°ƒç”¨å…¶ `get()`æ–¹æ³•è·å–ä»£ç†ç±»ã€‚Factory æ˜¯ WeakCache ä¸­çš„å†…éƒ¨ç±»ï¼ŒFactory.get() æ–¹æ³•ä¼šè°ƒç”¨ `ProxyClassFactory.apply()`æ–¹æ³•åˆ›å»ºå¹¶åŠ è½½ä»£ç†ç±».

**ä¼šæ£€æµ‹ä»£ç†ç±»éœ€è¦å®ç°çš„æ¥å£é›†åˆï¼Œç„¶åç¡®å®šä»£ç†ç±»çš„åç§°ï¼Œä¹‹ååˆ›å»ºä»£ç†ç±»å¹¶å°†å…¶å†™å…¥æ–‡ä»¶ä¸­ï¼Œæœ€ååŠ è½½ä»£ç†ç±»ï¼Œè¿”å›å¯¹åº”çš„ Class å¯¹è±¡ç”¨äºåç»­çš„å®ä¾‹åŒ–ä»£ç†ç±»å¯¹è±¡**

```java
    private static final class ProxyClassFactory
        implements BiFunction<ClassLoader, Class<?>[], Class<?>>
    {
        // prefix for all proxy class names
        private static final String proxyClassNamePrefix = "$Proxy";

        // next number to use for generation of unique proxy class names
        private static final AtomicLong nextUniqueNumber = new AtomicLong();

        @Override
        public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {

            Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
            for (Class<?> intf : interfaces) {
                /*
                 * Verify that the class loader resolves the name of this
                 * interface to the same Class object.
                 */
                Class<?> interfaceClass = null;
                try {
                    interfaceClass = Class.forName(intf.getName(), false, loader);
                } catch (ClassNotFoundException e) {
                }
                if (interfaceClass != intf) {
                    throw new IllegalArgumentException(
                        intf + " is not visible from class loader");
                }
                /*
                 * Verify that the Class object actually represents an
                 * interface.
                 */
                if (!interfaceClass.isInterface()) {
                    throw new IllegalArgumentException(
                        interfaceClass.getName() + " is not an interface");
                }
                /*
                 * Verify that this interface is not a duplicate.
                 */
                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                    throw new IllegalArgumentException(
                        "repeated interface: " + interfaceClass.getName());
                }
            }

            String proxyPkg = null;     // package to define proxy class in
            int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

            /*
             * Record the package of a non-public proxy interface so that the
             * proxy class will be defined in the same package.  Verify that
             * all non-public proxy interfaces are in the same package.
             */
            for (Class<?> intf : interfaces) {
                int flags = intf.getModifiers();
                if (!Modifier.isPublic(flags)) {
                    accessFlags = Modifier.FINAL;
                    String name = intf.getName();
                    int n = name.lastIndexOf('.');
                    String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
                    if (proxyPkg == null) {
                        proxyPkg = pkg;
                    } else if (!pkg.equals(proxyPkg)) {
                        throw new IllegalArgumentException(
                            "non-public interfaces from different packages");
                    }
                }
            }

            if (proxyPkg == null) {
                // if no non-public proxy interfaces, use com.sun.proxy package
                proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
            }

            /*
             * Choose a name for the proxy class to generate.
             */
            long num = nextUniqueNumber.getAndIncrement();
            String proxyName = proxyPkg + proxyClassNamePrefix + num;

            /*
             * Generate the specified proxy class.
             */
            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
                proxyName, interfaces, accessFlags);
            try {
                return defineClass0(loader, proxyName,
                                    proxyClassFile, 0, proxyClassFile.length);
            } catch (ClassFormatError e) {
                /*
                 * A ClassFormatError here means that (barring bugs in the
                 * proxy class generation code) there was some other
                 * invalid aspect of the arguments supplied to the proxy
                 * class creation (such as virtual machine limitations
                 * exceeded).
                 */
                throw new IllegalArgumentException(e.toString());
            }
        }
    }
```

> ğŸ¤”ï¼šè¿™å—ç›´æ¥æ‹¿å‡ºæ¥æ„Ÿè§‰æ²¡å¤´æ²¡è„‘çš„ï¼Œå®Œå…¨çœ‹ä¸æ‡‚ï¼Œæš‚æ—¶è·³è¿‡

### 4 JDBC è°ƒè¯•

åœ¨ MyBatis çš„æ—¥å¿—æ¨¡å—ä¸­æœ‰ä¸€ä¸ª Jdbc åŒ…ï¼Œå®ƒå¹¶ä¸æ˜¯å°†æ—¥å¿—ä¿¡æ¯é€šè¿‡ JDBC ä¿å­˜åˆ°æ•°æ®åº“ä¸­ï¼Œè€Œæ˜¯é€šè¿‡ JDK åŠ¨æ€ä»£ç†çš„æ–¹å¼ï¼Œå°† JDBC æ“ä½œé€šè¿‡æŒ‡å®šçš„æ—¥å¿—æ¡†æ¶æ‰“å°å‡ºæ¥

![image.png](http://ww1.sinaimg.cn/large/006rAlqhgy1gmbr28shylj318y07eaah.jpg)

åœ¨ BaseJdbcLogger ä¸­å®šä¹‰äº†`SET_METHODS`å’Œ`EXECUTE_METHODS`ä¸¤ä¸ª`Set<String>`ç±»å‹çš„é›†åˆï¼Œç”¨äºè®°å½•ç»‘å®š SQL å‚æ•°ç›¸å…³çš„`set*()`æ–¹æ³•åç§°ä»¥åŠæ‰§è¡Œ SQL è¯­å¥ç›¸å…³çš„æ–¹æ³•åç§°ï¼Œå…¶å®šä¹‰ä»¥åŠç›¸å…³é™æ€ä»£ç å—å¦‚ä¸‹ï¼š

```java
	// è®°å½•äº† PreparedStatement æ¥å£å®šä¹‰çš„å¸¸ç”¨çš„ set*() æ–¹æ³•
    protected static final Set<String> SET_METHODS;	

	// è®°å½•äº† Statement æ¥å£å’Œ PreparedStatement æ¥å£ä¸­ä¸æ‰§è¡Œ SQL è¯­å¥ç›¸å…³çš„æ–¹æ³•
    protected static final Set<String> EXECUTE_METHODS = new HashSet<>();

    static {
        SET_METHODS = Arrays.stream(PreparedStatement.class.getDeclaredMethods())
            .filter(method -> method.getName().startsWith("set"))
            .filter(method -> method.getParameterCount() > 1)
            .map(Method::getName)
            .collect(Collectors.toSet());

        EXECUTE_METHODS.add("execute");
        EXECUTE_METHODS.add("executeUpdate");
        EXECUTE_METHODS.add("executeQuery");
        EXECUTE_METHODS.add("addBatch");
    }
```

BaseJdbcLogger ä¸­æ ¸å¿ƒå­—æ®µçš„å«ä¹‰ï¼š

```java
// è®°å½•äº† PreparedStatement.set*() æ–¹æ³•è®¾ç½®çš„é”®å€¼å¯¹
private Map<Object,Object> columnMap = new HashMap<Object,Object>();

// è®°å½•äº† PreparedStatement.set*() æ–¹æ³•è®¾ç½®çš„ key å€¼
private List<Object> columnNames = new ArrayList<Object>();

// è®°å½•äº† PreparedStatement.set*() æ–¹æ³•è®¾ç½®çš„ value å€¼
private List<Object> columnsValues = new ArrayList<Object>();

// ç”¨äºè¾“å‡ºæ—¥å¿—çš„ Log å¯¹è±¡
protected int statementLog;

// è®°å½•äº† SQL çš„å±‚æ•°ï¼Œç”¨äºæ ¼å¼åŒ–è¾“å‡º SQL
protected int queryStack;
```

ConnectionLogger ç»§æ‰¿äº† BaseJdbcLogger æŠ½è±¡ç±»ï¼Œå…¶ä¸­å°è£…äº† `Connection`å¯¹è±¡å¹¶åŒæ—¶å®ç°äº† `InvocationHandler`æ¥å£ã€‚ `ConnectionLogger.newInstance()` æ–¹æ³•ä¸ºå…¶å°è£…çš„ `Connection`å¯¹è±¡åˆ›å»ºç›¸åº”çš„ä»£ç†å¯¹è±¡

```java
  public static Connection newInstance(Connection conn, Log statementLog, int queryStack) {
      // ä½¿ç”¨ JDK åŠ¨æ€ä»£ç†çš„æ–¹å¼åˆ›å»ºä»£ç†å¯¹è±¡
    InvocationHandler handler = new ConnectionLogger(conn, statementLog, queryStack);
    ClassLoader cl = Connection.class.getClassLoader();
    return (Connection) Proxy.newProxyInstance(cl, new Class[]{Connection.class}, handler);
  }
```

`ConnectionLogger.invoke()`æ–¹æ³•æ˜¯ä»£ç†å¯¹è±¡çš„æ ¸å¿ƒæ–¹æ³•ï¼Œå®ƒä¸º `prepareStatement()ã€prepareCall()ã€createStatement()`ç­‰æ–¹æ³•æä¾›äº†ä»£ç†,



PreparedStatementLogger.invoke() æ–¹æ³•ä¼šä¸º`EXECUTE_METHODS`é›†åˆä¸­çš„æ–¹æ³•ã€`SET_METHODS`é›†åˆä¸­çš„æ–¹æ³•ã€`getResultSet()`ç­‰æ–¹æ³•æä¾›ä»£ç ï¼š

```java
  @Override
  public Object invoke(Object proxy, Method method, Object[] params) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, params);
      }
      if (EXECUTE_METHODS.contains(method.getName())) {
        if (isDebugEnabled()) {
            // æ—¥å¿—è¾“å‡ºï¼Œè¾“å‡ºçš„æ˜¯å‚æ•°ä»¥åŠå‚æ•°ç±»å‹
          debug("Parameters: " + getParameterValueString(), true);
        }
          // æ¸…ç©º Base
        clearColumnInfo();
        if ("executeQuery".equals(method.getName())) {
          ResultSet rs = (ResultSet) method.invoke(statement, params);
          return rs == null ? null : ResultSetLogger.newInstance(rs, statementLog, queryStack);
        } else {
          return method.invoke(statement, params);
        }
      } else if (SET_METHODS.contains(method.getName())) {
        if ("setNull".equals(method.getName())) {
          setColumn(params[0], null);
        } else {
          setColumn(params[0], params[1]);
        }
        return method.invoke(statement, params);
      } else if ("getResultSet".equals(method.getName())) {
        ResultSet rs = (ResultSet) method.invoke(statement, params);
        return rs == null ? null : ResultSetLogger.newInstance(rs, statementLog, queryStack);
      } else if ("getUpdateCount".equals(method.getName())) {
        int updateCount = (Integer) method.invoke(statement, params);
        if (updateCount != -1) {
          debug("   Updates: " + updateCount, false);
        }
        return updateCount;
      } else {
        return method.invoke(statement, params);
      }
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
  }
```

StatementLogger çš„å®ç°ä¸ PreparedStatementLogger ç±»ä¼¼ï¼Œ 

ResultSetLogger ä¸­å°è£…äº† ResultSet å¯¹è±¡ï¼Œä¹Ÿç»§æ‰¿äº† `BaseJdbcLogger`æŠ½è±¡ç±»å¹¶å®ç°äº† InvocationHandler æ¥å£ã€‚ResultSetLogger ä¸­å®šä¹‰çš„å­—æ®µå¦‚ä¸‹ï¼š

```java
public final class ResultSetLogger extends BaseJdbcLogger implements InvocationHandler {
  	// è®°å½•äº†è¶…å¤§é•¿åº¦çš„ç±»å‹
  private static final Set<Integer> BLOB_TYPES = new HashSet<>();
    // æ˜¯å¦æ˜¯ ResultSet ç»“æœé›†çš„ç¬¬ä¸€è¡Œ
  private boolean first = true;
    // ç»Ÿè®¡è¡Œæ•°
  private int rows;
    // çœŸæ­£çš„ ResultSet å¯¹è±¡
  private final ResultSet rs;
    // è®°å½•äº†è¶…å¤§å­—æ®µçš„åˆ—ç¼–å·
  private final Set<Integer> blobColumns = new HashSet<>();
	
  static {
    BLOB_TYPES.add(Types.BINARY);
    BLOB_TYPES.add(Types.BLOB);
    BLOB_TYPES.add(Types.CLOB);
    BLOB_TYPES.add(Types.LONGNVARCHAR);
    BLOB_TYPES.add(Types.LONGVARBINARY);
    BLOB_TYPES.add(Types.LONGVARCHAR);
    BLOB_TYPES.add(Types.NCLOB);
    BLOB_TYPES.add(Types.VARBINARY);
  }

  private ResultSetLogger(ResultSet rs, Log statementLog, int queryStack) {
    super(statementLog, queryStack);
    this.rs = rs;
  }



  private void printColumnHeaders(ResultSetMetaData rsmd, int columnCount) throws SQLException {
    StringJoiner row = new StringJoiner(", ", "   Columns: ", "");
    for (int i = 1; i <= columnCount; i++) {
      if (BLOB_TYPES.contains(rsmd.getColumnType(i))) {
        blobColumns.add(i);
      }
      row.add(rsmd.getColumnLabel(i));
    }
    trace(row.toString(), false);
  }

  private void printColumnValues(int columnCount) {
    StringJoiner row = new StringJoiner(", ", "       Row: ", "");
    for (int i = 1; i <= columnCount; i++) {
      try {
        if (blobColumns.contains(i)) {
          row.add("<<BLOB>>");
        } else {
          row.add(rs.getString(i));
        }
      } catch (SQLException e) {
        // generally can't call getString() on a BLOB column
        row.add("<<Cannot Display>>");
      }
    }
    trace(row.toString(), false);
  }

  /**
   * Creates a logging version of a ResultSet.
   *
   * @param rs
   *          the ResultSet to proxy
   * @param statementLog
   *          the statement log
   * @param queryStack
   *          the query stack
   * @return the ResultSet with logging
   */
  public static ResultSet newInstance(ResultSet rs, Log statementLog, int queryStack) {
    InvocationHandler handler = new ResultSetLogger(rs, statementLog, queryStack);
    ClassLoader cl = ResultSet.class.getClassLoader();
    return (ResultSet) Proxy.newProxyInstance(cl, new Class[]{ResultSet.class}, handler);
  }

  /**
   * Get the wrapped result set.
   *
   * @return the resultSet
   */
  public ResultSet getRs() {
    return rs;
  }

}
```

`ResultSetLogger.invoke()`æ–¹æ³•çš„å®ç°ä¸ `ResultSet.next()`æ–¹æ³•çš„è°ƒç”¨è¿›è¡Œä¸€ç³»åˆ—åç½®æ“ä½œï¼Œé€šè¿‡è¿™äº›åç½®æ“ä½œä¼šå°† ResultSet æ•°æ®é›†ä¸­çš„è®°å½•å…¨éƒ¨è¾“å‡ºæ—¥å¿—ä¸­ã€‚

```java
  @Override
  public Object invoke(Object proxy, Method method, Object[] params) throws Throwable {
    try {
      if (Object.class.equals(method.getDeclaringClass())) {
        return method.invoke(this, params);
      }
      Object o = method.invoke(rs, params);
        // é’ˆå¯¹ next æ–¹æ³•çš„å¤„ç†
      if ("next".equals(method.getName())) {
        if ((Boolean) o) {
          rows++;
          if (isTraceEnabled()) {
            ResultSetMetaData rsmd = rs.getMetaData();
              // æ•°æ®é›†çš„åˆ—æ•°
            final int columnCount = rsmd.getColumnCount();
            if (first) {
              first = false;
                // é™¤äº†è¾“å‡ºè¡¨å¤´ï¼Œè¿˜ä¼šå¡«å…… blobColums é›†åˆï¼Œè®°å½•è¶…å¤§ç±»å‹çš„åˆ—
              printColumnHeaders(rsmd, columnCount);
            }
              // è¾“å‡ºè¯¥è¡Œè®°å½•ï¼Œæ³¨æ„ä¼šè¿‡æ»¤æ‰ blobColums ä¸­è®°å½•çš„åˆ—ï¼Œè¿™äº›åˆ—çš„æ•°æ®è¾ƒå¤§ï¼Œä¸ä¼šè¾“å‡ºåˆ°æ—¥å¿—
            printColumnValues(columnCount);
          }
        } else {
            // éå†å®Œ ResultSet ä¹‹åï¼Œä¼šè¾“å‡ºæ€»å‡½æ•°
          debug("     Total: " + rows, false);
        }
      }
      clearColumnInfo();
      return o;
    } catch (Throwable t) {
      throw ExceptionUtil.unwrapThrowable(t);
    }
  }
```

## 5 èµ„æºåŠ è½½

```
industrial-is-gases-app
```