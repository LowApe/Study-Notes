# 简单动态字符串

Redis 没有直接使用 C语言传统的字符串(以空字符结尾的字符数组，简称 C字符串)，而是自己构建了一种名为简单动态字符串(simple dynamic string,SDS)的抽象类型，并将 SDS 作为 Redis 的默认字符串表示

- 当Redis 需要的仅仅是一个字符串字面量
- 而是一个可以被修改的字符串值时，Redis 就会使用 SDS 来表示字符串值

```shell
redis> SET msg "hello world"
```

- 键值对的键是一个字符串对象
- 键值对的值是一个字符串对象，对象的底层实现是一个保存着字符串"hello world" 的 SDS

```shell
redis> RPUSH fruits "apple" "banana" "cherry"
(integer) 3
```

- 键值对的键是一个字符串对象
- 键值对的值是一个**列表对象**，列表对象包含了三个字符串对象，这三个字符串对象分别由三个 SDS 实现

> 除了用来保存数据库中的字符串值之外，SDS 还被用作缓冲区(buffer):**AOF 模块中的 AOF 缓冲区，以及客户端状态的输入缓冲区**，都是由 SDS 实现的，在之后介绍 AOF 持久化和客户端状态的时候，我们会看到 SDS 在这两个模块中的应用

## SDS的定义

每个 sds.h/sdshdr 结构表示一个 SDS 值：

```c
struct sdshdr{
  //记录 buf 数组中已使用字节的数量
  //等于 SDS 所保存字符串的长度
  int len;
  
  // 记录 buf 数组中未使用字节的数量
  int free;
  
  //字节数组，用于保存字符串
  char buf[];
}

```

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g7zsc3mzasj30fa05i3zh.jpg)

SDS 遵循 C 字符串以空字符结尾的惯例，保存空字符的 1 字节空间不计算在 SDS 的 leb 属性里面，并且为空字符分配额外的 1 字节空间，以添加这个空字符对于 SDS 的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS 可以直接重用一部分 C 字符串函数里面的函数

> 举个例子，如果我们有一个 SDS 指针 s ，那么我们可以直接使用 <stdio.h>printf 函数，通过执行一下语句：

```c
printf("%s",s->buf)
```

来打印出 SDS 保存的字符串值 "Redis"，而无需为 SDS 编写专门的打印函数

## SDS 与 C 字符串的区别

**复习直接跳转到小结**

C 语言使用长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组的最后一个元素总是空字符 `\0`

C 语言这种字符串表示方式，不能满足 Redis 对字符串在安全性、效率以及功能方面的要求。后面会说明 SDS 比 C 字符串更适合于 Redis 的原因

### 常数复杂度获取字符串长度

因为 C 字符串并不记录自身长度，所以为了获取一个 C 字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为 O(N)

和 C 字符串不同，因为 SDS 在 len 属性中记录了 SDS 本身的长度，所以获取一个 SDS 长度的复杂度为 O(1)

> 💡提示：通过使用 SDS 而不是 C 字符串，Redis 将获取字符串长度所需的复杂度从 O(N)降低到了 O(1),确保了获取字符串长度的工作不会成为 Redis 性能瓶颈

### 杜绝缓冲区溢出

除了获取字符串长度的复杂度高之外，C 字符串不记录自身长度带来的另一个问题是**容易造成缓冲区溢出(buffer overflow)**

> 举个例子，<stdio.h>/strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾：

```c
char *strcat (char *dest,const char *src);
```

因为 C 字符床不记录自身的长度，所以 strcat 假定用户在执行这个函数时，为 dest 分配的内存，不足以容纳 src 字符串的所有内容，就会产生缓冲区溢出

> 举个例子，假设程序里有两个内存中紧邻着的C 字符串 s1 和 s2 ，其中 s1 保存了字符串 "Redis"，而 s2 则保存了字符串 "MongoDB"，如图 2-7 所示

![image.png](http://ww1.sinaimg.cn/mw690/006rAlqhly1g7zt6801ybj30p80363zr.jpg)

如果执行：

```c
strcat(s1,"Cluster")
```

将 s1 的内容修改为 “Redis Cluster”，但粗心忘记为 s1 分配足够的空间，在 strcat 函数执行后，s1 的数据将溢出到 s2 所在的空间，导致 s2 保存的内容被意外地修改

![image.png](http://ww1.sinaimg.cn/mw690/006rAlqhly1g7zt8pdu2ej30qc03egn0.jpg)

> 💡提示：与 C 字符串不同，SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API 需要对 SDS 进行修改时，API 会先**检查 SDS 的空间**是否满足修改所需的要求，如果不满足的话，API 会自动将 SDS 空间扩展至执行修改所需的大小，然后才执行实际的修改操作

### 减少修改字符串时带来的内存重分配次数

因为 C 字符串的长度和底层数组的长度之间存在着 N+1 的关联性，所以每次增长或者缩短一个 C 字符串，程序都要对保存这个 C 字符出啊的数组进行一次**内存重分配**操作

- 如果程序执行的是增长字符串的操作，比如拼接操作(append)，那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层的空间大小--如果忘了这一步会产生**缓存溢出**
- 如果程序执行的是缩短字符串的操作，比如截断操作(trim)，那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间--忘记会产生**内存泄漏**

> 举个例子：如果我们持有一个值为 “Redis” 的 C 字符串 s，那么为了将 s 的值改为“Redis Cluster”，执行`strcat(s,"Cluster")`之前，内存重分配，扩展 s 空间。之后，我们有打算将 s 的值进行扩展，那么同上	

因为内重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作：为了避免 C 字符串这种缺陷，SDS通过未使用空间实现**空间预分配**和**惰性空间释放**两种优化策略

1. 空间预分配

当 SDS 当 API 对一个 SDS 进行修改，并且需要对 SDS 进行空间扩展的时候，程序不仅会为 SDS 分配修改所必须要的空间，还会为 SDS 分配额外的未使用空间。其中额外分配的未使用空间数量公式：

| 对SDS进行修改，SDS 长度 < 1MB                                | 对SDS进行修改，SDS 长度 >= 1MB                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 分配和 len 属性同样的未使用空间                              | 分配 1MB 的未使用空间                                        |
| 例子：修改后 len 为 13 字节，SDS 的 buf 数组的实际长度将变成 13+13+1=27 字节 | 例子：修改后 的 len 为 30MB，那么程序会分配 1MB 的未使用空间，SDS 的 buf 数组的实际长度将会为 30MB + 1MB + 1byte |

2. 惰性空间释放

惰性空间释放用于**优化 SDS 的字符串缩短**操作，当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量纪录，等待将来使用



### 二进制安全

 C 字符串中的字符必须符合某种编码(比如 ASCII)，并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符会被误认为是字符串结尾，这些限制使得 C 字符串只能保存文本数据，而不能保存图片、视频、压缩文件等这样的二进制数据。

为了确保 Redis 可以适用于各种不同的使用场景，SDS 的 API 都是二进制安全的，所有 SDS API 都会处理二进制的方式来处理 SDS 存放在 buf 数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设。这也是 SDS 的 buf 属性称为**字节数组**原因。**因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束**

### 兼容部分 C 字符串函数

SDS 还是遵循 C 字符串以**空字符结尾**的惯例：这些 API 总会将 SDS 保存的数据的末尾设置为空字符，并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符，为了让那些保存文本数据的 SDS 可以重用一**部分 <string.h>库定义的函数**

### 总结

| C字符串                                        | SDS                                            |
| :--------------------------------------------- | :--------------------------------------------- |
| 获取串长度的复杂度为O(N)                       | 获取串长度的复杂度为O(1)                       |
| API 是不安全的，可能造成缓冲区溢出             | API 是安全的，不会造成缓冲区溢出               |
| 修改字符床长度 N 次必然需要执行 N 次内存重分配 | 修改字符串长度 N 次最多需要执行 N 次内存重分配 |
| 只能保存文本数据                               | 可以保存文本或者二进制数据                     |
| 可以使用所有<string.h>库中函数                 | 可以使用一部分<string.h>库中函数               |

## SDS API

![image.png](http://ww1.sinaimg.cn/mw690/006rAlqhly1g7zv56icx2j30ti0e2ajh.jpg)

![image.png](http://ww1.sinaimg.cn/mw690/006rAlqhly1g7zv5hqo3qj30ti0akagm.jpg)

## 重点回顾

- Redis 只会使用 C 字符串作为字面量，在大多数情况下，Redis 使用 SDS(simple dynamic string)作为字符串表示
- 比起 C 字符串，SDS 具有一下优点
    - 常数复杂度获取字符串长度
    - 杜绝缓冲区溢出
    - 减少修改字符串时带来的内存重新分配次数
    - 二进制安全
    - 兼容部分 C 字符串函数

# 链表

# 字典



# 跳跃表



# 整数集合



# 压缩列表



# 对象

