# 目录
<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [目录](#目录)
- [什么是面向切面编程?](#什么是面向切面编程)
	- [定义 AOP 术语](#定义-aop-术语)
		- [通知(Advice)](#通知advice)
		- [连接点(join point)](#连接点join-point)
		- [切点(Poincut)](#切点poincut)
		- [切面(Aspect)](#切面aspect)
		- [引入(Introduction)](#引入introduction)
		- [织入(Weaving)](#织入weaving)
	- [Spring 对 AOP 的支持](#spring-对-aop-的支持)
	- [Spring 通知是 Java 编写的](#spring-通知是-java-编写的)
		- [Spring 在运行时通知对象](#spring-在运行时通知对象)
		- [Spring 只支持方法级别的连接点](#spring-只支持方法级别的连接点)
- [通过切点来选择连接点](#通过切点来选择连接点)

<!-- /TOC -->

在软件开发中,散布与应用中多处的功能被称为横切关注点(cross-cutting concern),这些横切关注点从概念上是与应用的业务逻辑相分离的(但是往往会直接嵌入到应用的业务逻辑之中) 把这些横切关注点与业务逻辑相分离正是面向切面编程(AOP)索要解决的问题

前面,我们介绍了如何使用依赖注入(DI) 管理和配置我们的应用对象.DI 有助于应用对象之间的解耦,而 AOP 可以实现横切关注点与我们所影响的对象之间的解耦.

日志是应用切面的常见范例,但它并不是切面适合的唯一场景.通览本书,我们还会看到切面所使用的多个场景,包括声明式事务,安全和缓存.

本章展示了Spring对切面的支持，包括如何把普通类声明为一个切面和如何使用注解创建切面。除此之外，我们还会看到AspectJ——另一种流行的AOP实现——如何补充Spring AOP框架的功能。但是，我们先不管事务、安全和缓存，先看一下Spring是如何实现切面的，就从AOP的基础知识开始吧。

# 什么是面向切面编程?
切面能帮助我们模块化横切关注点.横切关注点可以被`描述为影响应用多处的功能`.例如,安全就是一个横切关注点

![](http://ww1.sinaimg.cn/large/006rAlqhly1g2826dzjy6j309205p3zg.jpg)

图示展现了一个被划分为模块的典型应用.每个模块的核心功能都是为特定业务领域提供服务,但是这些模块都需要类似的辅助功能,例如安全和事务管理


如果重用通用功能的话,最常见的面相对象技术是继承(inheritance)或委托(delegation).但是,如果在整个应用中都使用相同的基类,继承往往会导致一个脆弱的对象体系;而使用委托可能需要对委托对象进行复杂的调用.

切面提供了取代继承和委托的另一种可选方案,而且在很多场景下更清晰简洁.在使用面向切面编程时,我们任然在一个地方定义通用功能,但是可以通过`声明的方式`定义这个功能要以何种方式在何处应用,而无需修改受影响的类.横切关注点可以被`模块化为特殊的类`
,这个类被称为切面(aspect). 这样做有两个好处:
- 首先,现在每个关注点都集中于一个地方,而不是分散到多处代码中
- 服务模块更简洁,因为我们只包含主要关注点(或核心功能)的代码,而次要关注点的代码转移到切面了.

## 定义 AOP 术语

与大多数技术一样,AOP 已经形成了自己的术语.描述切面的常用术语有`通知(advice)`,`切点(pointcut)`,`连接点(join point)`,下图在一个或多个连接点上,可以把切面的功能(通知)织入到程序的执行过程中

![](http://ww1.sinaimg.cn/large/006rAlqhly1g282lbqv0xj309805swez.jpg)

### 通知(Advice)
类似地,切面也有目标,它必须要完成的工作.在 AOP 术语中,切面的工作称为通知.

通知定义了切面是什么以及何时使用.除了描述切面要完成的工作,通知还解决了何时执行这个工作的问题.它应该应用在某个方法被调用之前?之后?之前和之后都调用?还是只在方法抛出异常时调用?

Spring 切面可以应用 5 种类型的通知:
- 前置通知(Before):在目标方法被调用之前调用通知功能;
- 后置调用(After):在目标方法完成之后调用通知,此时不会关系方法的输出是什么.
- 返回通知(After-returning):在目标方法成功执行之后调用通知;
- 异常通知(After-throwing):在目标方法抛出异常后调用通知;
- 环绕通知(Around):通知包裹了被通知的方法,在被通知的方法调用之前和调用之后执行自定义的行为.

### 连接点(join point)

我们应用可能也有数以千计的时机应用通知.这些时机被称为`连接点`.连接点是在应用执行过程中能够`插入切面`的一个点.这个点可以是调用方法时,抛出异常时,甚至修改一个字段时.`切面代码`可以定义这些点插入到应用的正常流程之中,并添加新的行为.

### 切点(Poincut)

一个切面并不需要通知应用的所有连接点.切点有助于缩小`切面`所通知的连接点的范围.

如果说通知定义了切面的"什么" 和 "何时" 的话,那么切点就定义了"何处".切点的定义会匹配`通知`所要织入的一个或多个连接点.我们通常使用明确的类和方法名称,或是利用正则表达式定义所匹配的类和方法名称来指定这些切点,可以根据运行时的决策(比如方法的参数值)来决定是否应用通知.

> flag: 不是很理解最后一句话

### 切面(Aspect)
切面是通知和切点的结合.通知和切点共同定义了切面的全部内容(它是什么,在何时和何处完成其功能)

### 引入(Introduction)
引入允许我们可以创建一个 Auditable 通知类,该类记录了对象最后一次修改时的状态.只需一个方法,setLastModified(Date),和一个实例变量来保存这个状态.然后,这个新方法和实例变量就可以被引入到现有的类中,从而可以在无需修改现有类的情况下,让我们具有新的行为和状态.

### 织入(Weaving)

织入是把切面应用到目标对象并创建新的代理对象的过程.切面在指定的连接点被织入到目标对象中.在目标对象的生命周期里有多个点可以进行织入:

- 编译器:切面在目标类编译时被织入.这种方式需要特殊的编译器.Aspect J 的织入编译器就是以这种方式切面的.
- 类加载器:切面在目标类加载到 JVM 时被织入.这种方式需要特殊的类加载器(ClassLoader),它可以在目标类被引入应用之前增强该目标类的字节码.Apect J 5 的加载时织入(load-time weaving,LTW)就支持以这种方式织入切面.
- 运行期:切面在应用运行的某个时刻被织入.一般情况下,在织入切面时,AOP 容器会为目标对象动态地创建一个代理对象.Spring AOP 就是这种方式织入切面的.

> 通知包含了需要用于多个应用对象的横切行为;连接点是程序执行过程中能够应用通知的所有点;切点定义了通知被应用的具体位置(在那些连接点).其中关键的概念是切点定义了那些连接点会得到通知.


## Spring 对 AOP 的支持

并不是所有的AOP框架都是相同的，它们在连接点模型上可能有强弱之分。有些允许在字段修饰符级别应用通知，而另一些只支持与方法调用相关的连接点。它们织入切面的方式和时机也有所不同。但是无论如何，创建切点来定义切面所织入的连接点是AOP框架的基本功能。

Spring 提供了4种类型的AOP支持:
- 基于代理的经典 Spring AOP;
- 纯 POJO 切面
- `@Aspect J` 注解驱动的切面
- 注入式 Aspect J 切面(适合于 Spring 各版本)

前三种都是 Spring AOP 实现的变体,Spring AOP 构建在动态代理基础之上,因此,Spring 对 AOP 的支持局限于方法拦截.

借助 Spring 的 AOP 命名空间,我们可以将纯 POJO 转换为切面.实际上,这些 POJO 只是提供了满足切点条件时所要调用的方法.遗憾的是,这种技术需要 XML 配置,但这的确是`声明式`地将对象转换为切面的简便方法.

Spring 借鉴了 Aspect J 的切面,以提供注解驱动的 AOP .本质上,它依然是 Spring 基于代理的 AOP,但是编程模型几乎与编写成熟的 Aspect J 注解切面完全一致.这种 AOP 风格的好处在于能够不使用 XML 来完成功能.

如果你的 AOP 需求超过了简单的方法调用(如构造器或属性拦截),那么你需要考虑使用 Aspect J 来实现切面.在这种情况下,上文第四种类型能帮助你将值注入到 Aspect J 驱动的切面中.

## Spring 通知是 Java 编写的

Spring 所创建的`通知`都是用标准的 Java 类编写的.这样的话,我们就看可以使用与普通 Java 开发一样的集成开发环境(IDE) 来开发切面.而且,定义通知所应用的切点通常会使用注解或在 Spring 配置文件里采用 XML 来编写,这两种语法对于 Java 开发者来说都是相当熟悉的.

Aspect J 与之相反.虽然 Aspect J 现在支持基于注解的切面,但 Aspect J 最初是以 Java 语言扩展的方式实现的.这种方式有优点也有缺点.通过特有的 AOP 语言,我们可以获得更强大和细粒度的控制,以及更丰富的 AOP 工具集,但是我们需要额外学习新的工具和语法

### Spring 在运行时通知对象

通过在代理类中包裹切面,Spring 在运行期把切面织入到 Spring 管理的 bean 中.代理类封装了目标类,并拦截被通知方法的调用,再把调用转发给真正的目标 bean

![](http://ww1.sinaimg.cn/large/006rAlqhly1g28e6l4f6wj30bd05u0t5.jpg)

当代理拦截到方法调用时,在调用目标 bean 方法之前,会执行切面逻辑.

直到应用需要被代理的 bean 时,Spring 才创建代理对象.如果使用的是 ApplicationContext 的话,在 ApplicationContext 从 BeanFactory 中加载所有 bean 的时候,Spring 才会创建被代理的对象. 因为 Spring 运行时才创建代理对象,所有我们不需要特殊的编译器来织入 Spring AOP 的切面.

### Spring 只支持方法级别的连接点
正如前面所探讨过的,通过使用各种 AOP 方案可以支持多种连接点模型. 因为 Spring 基于动态代理,所有 Spring 只支持方法连接点.这与一些其他的 AOP 框架是不同的,例如 Aspect J 和 JBoss,除了方法切点,它们还提供字段和构造器接入点.Spring 缺少对字段连接点的支持,无法让我们创建细粒度的通知,例如拦截对象字段的修改.而且它不支持构造器连接点,我们就无法在 bean 创建时应用通知.

但是方法拦截可以满足绝大部分的需求.如果需要方法拦截之外的连接点拦截功能,那么我们可以利用 Aspect 来补充 Spring AOP 的功能

# 通过切点来选择连接点

> flag: 停止做这样无灵魂的笔记,突然意识到这样边看书边记笔记,并实现代码的效率太差了,整个人的注意力被无限分散,感觉到自己好无力.
