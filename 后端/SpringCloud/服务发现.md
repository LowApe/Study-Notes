# 服务发现

在任何分布式架构中，都需要找到机器所在的物理地址。服务发现非常简单，只需要维护一个属性文件，这个属性文件包含应用程序使用的所有远程服务地址。服务发现最重要两个原因：

- 快速地对在环境中运行的服务实例数量进行水平伸缩。可以通过增加更好的硬件(垂直伸缩)的方法来扩大服务，添加更多服务器(水平伸缩)来实现扩大
- 有助于提高应用程序的弹性。当微服务实例变得不健康或不可用时，大多数服务发现从内部服务列表移除该实例

传统服务位置通常由 DNS 和 网络负载均衡器的组合来解决，但基于云的微服务应用程序来说，这种模型并不适用：

- 单点故障
- 有限的水平可伸缩性
- 静态管理
- 复杂

# 云中的服务发现

基于云的微服务环境的解决方案是使用服务发现机制，这一机制特点：

- 高可用
- 点对点 服务发现集群中的每个节点共享服务实例的状态
- 负载均衡
- 有弹性
- 容错

# 服务发现架构

下面概念在所有服务发现实现中是共通的

- 服务注册——服务如何使用服务发现代理进行注册？
- 服务地址的客户端查找——服务客户端查找服务信息的方法是什么？
- 信息共享——服务跨节点共享服务信息？
- 健康检测——服务如何将它的健康信息传回给服务发现代理？

![image.png](http://ww1.sinaimg.cn/mw690/006rAlqhgy1glput3i26wj30r60mqn3v.jpg)

当服务实例启动时，它们将通过一个或多个服务发现实例来注册它们(服务发现实例)可以访问 **物理位置、路径和端口**。服务 ID 是唯一标识一组相同服务实例的键。

服务通常只在一个服务发现实例中进行注册。大多数服务发现的实现使用数据传播的点对点模型，每个服务实例的数据都被**传递到服务发现集群中的所有其他节点**

**服务实例将通过服务发现去推送服务实例的状态，或者服务发现从服务实例拉取状态**。任何未能返回良好的健康检查信息的服务都将从可用服务实例池中删除。

客户端可以使用不同的模型来发现服务。在每次调用服务时，客户端可以只依赖于服务发现引擎来解析服务位置。这种方法很脆弱，因为服务客户端完全依赖于服务发现引擎来查找和调用服务。

![image.png](http://ww1.sinaimg.cn/mw690/006rAlqhgy1glpv7x27t9j30qu0qiahw.jpg)

一种更健壮的方法：当服务消息者需要调用一个服务时：

1. 它将联系服务发现服务，获取它请求的所有服务实例，然后在服务消费者的机器上 **本地缓存数据**
2. 每当客户端需要调用该服务时，服务消费缓存中查找该服务的位置。通常，客户端缓存将使用简单的负载均衡算法，**如"轮询"负载均衡算法，以确保服务调用分布在多个服务实例之间**
3. 然后，客户端将**定期与服务发现服务进行联系，并刷新服务实例的缓存**。客户端缓存保存一致性，但是始终存在这样的风险：**在客户端联系服务发现实例以进行刷新和调用时，调用可能会被定向到不健康的服务实例上。**
4. 如果调用服务的过程中，服务调用失败，那么本地的服务发现缓存失效，服务发现客户端将尝试从服务发现代理刷新数据



