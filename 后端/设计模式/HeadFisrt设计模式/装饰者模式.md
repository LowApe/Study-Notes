
# 装饰者模式

利用继承设计子类的行为,是在编译时静态决定的，而且所有的子类都会继承到相同的行为。如何使用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展

> 装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案

# 开放-关闭原则

> 设计原则：类应该对扩开放，对修改关闭

- 装饰者和被装饰者拥有相同的超类
- 可以拥有一个或者多个装饰者包装一个对象
- **装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的**
- 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量的用你喜欢的装饰者来装饰




# 创建装饰者
1. 定义抽象组件(基类)
2. 扩展抽象组件成为具体组件(类型)
3. 根据抽象组件创建抽象装饰着
4. 创建具体的装饰着

```java
public class CurrentDecorator extends CondimentDecorator{
    FatherAbstractor fatherAbstractor;

    public CurrentDecorator(FatherAbstractor fatherAbstractor){
        this.fatherAbstractor = fatherAbstractor;
    }

    //复写抽象方法，调用被包装的类
}
```

> 真实世界的装饰者: Java I/O

# 要点

- 继承属于扩展形式之一,但不见得是达到弹性设计的最佳方式
- 在我们的设计中，应该允许被扩展，而无需修改现有的代码
- 组合和委托可用于在运动时也可以让我们扩展行为
- 除了继承，装饰者模式也可以让我们扩展行为。
- 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型
- 装饰者会导致设计中出现很多小对象，如果过度使用，让程序变得很复杂
