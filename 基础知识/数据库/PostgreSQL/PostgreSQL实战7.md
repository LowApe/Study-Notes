# 事务与并发控制

> 为了控制并发事务之间的相互影响，解决并发可能带来的资源征用及数据不一致问题，数据库的**并发控制系统引入了基于锁的并发控制机制(Lock-Based Concurrency Control)和基于多版本的并发控制机制 MVCC(Multi-Version Concurrencu Control)**

# 1 事务和并发控制的概念

事务的四个重要的特性

- 原子性 (要么全部执行，要么全部不执行)
- 一致性
- 隔离性（确保事务与事务并发执行正常）
- 持久性

## 并发引发的现象

| 现象       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 第一个事务读取了第二个事务已经修改但还未提交的数据<br />如果第二个事务不提交并执行了 ROLLBACK 后，<br />第一个事务读取数据是不正确的，这种现象称作脏读 |
| 不可重复度 | 当一个事务第一次读取数据之后，被读取的数据被另一个已提交的事务进行了修改，事务再次读取这些数据时发现两次查询结果不一致。**同一条记录的值不同了** |
| 幻读       | 一个事务的两次查询的**结果集记录数不一致**。                 |
| 序列化异常 |                                                              |

> 注意⚠️：
>
> **PostgreSQL 数据库中无论如何都无法产生脏读**：由于内部将 read uncommited 设计为和 read commited 一样，:sos:：这块有关隔离级别



## ANSI SQL 标准的事务隔离级别

> 为了避免事务与事务之间并发执行引发的副作用，最简单的方法是**串行化地逐个执行事务，但是会降低系统吞吐量等** ANSI SQL 标准定义了四类隔离级别。**通过这些事务隔离界别规定一个事务必须与其他事务所进行的资源或数据更改相隔离的程度**

| 隔离级别                    | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| Read Uncommitted (读未提交) |                                                              |
| Read Committed(读已提交)    | PostgreSQL 的默认隔离级别，它满足了一个事务只能看见已经提交了 |
| Repeatable Read(可重复度)   | 确保同一个事务的多个实例在并发读取数据时，会看到同样的数据行 |
| Serializable(可序列化)      | 最高的隔离级别，**通过强制事务排序，使之不可能相互冲突，从而解决幻读问题** 它是在每个读的数据行上加上共享锁 |



隔离级别与读现象的关系：

| 隔离级别                    | 脏读   | 不可重复度 | 幻读   |
| --------------------------- | ------ | ---------- | ------ |
| Read Uncommitted (读未提交) | 可能   | 可能       | 可能   |
| Read Committed(读已提交)    | 不可能 | 可能       | 可能   |
| Repeatable Read(可重复度)   | 不可能 | 不可能     | 可能   |
| Serializable(可序列化)      | 不可能 | 不可能     | 不可能 |

> 对多数应用程序，优先考虑 Read Commited 隔离级别。它能够避免脏读，而且具有较好的并发性能。尽管会导致**不可重复读、幻读和和丢失更行这些并发问题，在这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制**



# 2 PostgreSQL 的事务隔离界别

# 相关链接