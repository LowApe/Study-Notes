# 散列表
本章内容：
- 学习散列表
- 学习散列表的内部机制：实现、冲突和散列函数

> 相对于之前学的二分查找O(logn)和简单查找O(n)，还用更快的散列表O(1)

# 散列函数

> 散列函数：无论你给他什么数据，他都通过计算都出一个数字

散列函数必须满足一些要求：
- 它必须是一致的。每次输入相同的数据和输出的数据保持一致
- 它应将不同的输入映射到不同的数字

    散列函数准确的指出对应的存储位置：

- 散列函数总是将相同的输入映射到相同的索引
- 散列函数将不同的输入映射到不同的索引
- 散列函数知道数组有多大，只返回有效的索引

> 散列函数+数组=散列表，任一优秀的语言都提供了散列表实现。python提供的散列表实现为字典，你可使用函数 dict来创建列表

```python
book = dict()
book["apple"] = 0.67
book["milk"] = 1.49
print book
{'apple':0.67,'milk':1.4}
print book['apple']
0.67
```

# 散列的应用案例
- 手机电话簿：姓名对应一个电话号（仿真映射）
- 防止重复：投票管理，一个名字只能投一票
- 缓存：网页访问，可以将访问过的页面数据缓存下来

```python
//网页缓存实例
cache ={} # 等价于 cache = dict()
def get_page(url):
    if cache.get(url):
        return cache[url]
    else:
        data = get_data_from_server(url)
        cache[url] = get_data_from_server
        return data
```

## 小结
- 仿真映射关系
- 防止重复
- 缓存/记住数据，以免服务器再通过处理来生成它们

# 冲突
> 首先不可能编写一个总是将不同的键映射到数组的不同位置的散列函数，当散列函数不同输入结果一致就产生了**冲突**，给两个健分配到了相同的位置，散列表要保证一致性，所以我们要解决冲突

解决冲突方式很多
最简单的办法将两个键映射到同一个位置，在这个位置存储一个链表，如果存储链表很长，散列表速度将急剧下降。所以要设计好的散列函数。

# 性能
![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g7jtncvdcdj30ta0ksn7s.jpg)

从上图，需要避免最糟情况至关重要
- 较低的填装因子
- 良好的散列函数


## 填充因子

填充因子 = 散列表包含的元素数/位置总数

> 如果填充因子很大，可以通过调整散列表长度，但是开销很大

## 良好的散列函数
良好的散列函数让数组中的值呈均匀分布

# 小结
- 你可以结合散列函数和数组来创建散列表
- 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数
- 散列表的查找、插入和删除速度都非常快
- 散列表适合用于仿真映射关系
- 一旦填装因子超过0.7，就该调整散列表的长度
- 散列表可用于**缓冲数据**
- 散列表非常合适用于**防止重复**
