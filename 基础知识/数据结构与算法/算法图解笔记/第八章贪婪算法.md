# 贪婪算法
本章内容
- 学习如何处理不可能完成的任务:没有快速算法的问题(NP完全问题)
- 学习识别NP完全问题
- 学习近似算法，使它们可快速找到NP完全问题的近似解
- 学习贪婪策略--一种非常简单的问题解决策略

# 教室调度问题
实例：根据课表安排能在同一间教室尽可能上多的课。
![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g7m57ja2ghj30us0csjv4.jpg)

具体做法:
1. 选出结束最早的课，它就是要在这间教室上的第一堂课
2. 接下来，必须选择第一堂课结束后才开始的课。
3. 重复上面，得出答案

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g7m5dj55mfj30vg05kjtz.jpg)

这正是贪婪算法的优点--简单易行，每步都采取最优的做法。这个示例中，每次都选择结束最早的课。用专业术语说，就是你每步都选择**局部最优解**，最终得到的就是**全局最优解**，贪婪算法并非在任何情况下都有效。

# 背包问题
实例：假设你是贪婪的小偷，有个能偷35kg的背包，现在有三种东西

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g7m5t49rfwj30v80a8dkc.jpg)

如果采用最优解，选择音响，则不如后两种之和合适，但是也是非常接近了。

> 在有些情况下，完美是优秀的敌人。有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近

# 集合覆盖问题
实例：有五十个城市，有不同广播台覆盖不同的城市，如何选择最小集合的广播台，使得同时五十个城市一同广播，广播台之间的城市可能存在重叠。

1. 列出每个可能的广播台集合，这被称为**幂集(power set)** 可能的子集有 2^n 个(n是广播台集合)
2. 在这些集合中，选出覆盖50个城市的最小集合

> 🤔️思考：幂集，和这个 $2^n$ 怎么来的<br>
设集合A是有基数Card(A)的有限集(可数集)，则**Card($2^A$)=$2^(Card(A))$** <br>
如集合B={a,b},得 2^B={空集,{a},{b},{a,b}}.那么 Card($2^B$)=$2^(Card(B))$=$2^2$=4




问题是计算每个可能的广播台子集需要多少时间。由于可能的集合有 $2^n$,因此运行时间为**O($2^n$)** ，如果广播台不多，只用5～10个，这是可行的。如果广播台很多，结果呢？假设**每秒可计算10个子集**，需要的时间：


| 广播台数量 |  子集总数 $2^n$  |  需要的时间    |
| :------------- | :------------- |:------------- |
|    5   |    32  |3.2s|
|    10   |    1024  |102.4s|
|    32   |    4294967296  |13.6年|

## 近似算法

使用贪婪算法可得到非常接近的解
1. 选出这样一个广播台，即可**覆盖最多**的未覆盖城市。即便这个广播台覆盖了一些已覆盖的城市也没关系
2. 重复第一步，直到覆盖了所有的城市

> 在获得精确解需要的时间太长时，可食用近似算法。判断近似算法优劣的标准:
- 速度有多快
- 得到的近似解与最优解的接近成都

贪婪算法是个不错选择，而且速度很快，这个例子中，贪婪算法的运行时间为O(n^2)[每次从n中找到一个最多覆盖],其中n为广播台数量

代码：<br>
出于简化，这里假设要覆盖的城市没有那么多

```python
# 创建一个列表，其中包含要覆盖的城市
states_needed = set(["mt","wa","or","id","nv","ut","ca","az"]) # 传入一个数组，它被转换为集合，集合重复的只能存在1次

# 广播清单，用散列表表示,键为广播台名称，值为覆盖城市
stations = {}
stations["kone"] = set(["id","nv","ut"])
stations["ktwo"] = set(["wa","id","mt"])
stations["kthree"] = set(["or","nv","ca"])
stations["kfour"] = set(["nv","ut"])
stations["kfive"] = set(["ca","az"])

# 需要一个集合来存储最终选择的广播台
final_stations = set()
```


遍历所有广播台，从中选择覆盖了**最多的未覆盖城市**的广播台

```python
while states_needed:
    best_station = None  #覆盖最多广播台
    states_covered = set()  #  需要覆盖的城市
    for station,states_for_station in stations.items():  # station 广播台 states_for_station 站台所覆盖的城市
        covered = states_needed & states_for_station  # 广播台覆盖的一系列还未覆盖的城市
        if len(covered) > len(states_covered):  # 检查该广播台覆盖的州是否比 best_station 多
            best_station = station
            states_covered = covered
        states_needed - = states_covered
    final_stations.add(best_station)
print(final_stations)
```
**小结**<br>

- 集合类似于列表，只是不能包含重复的元素；
- 你可执行一些有趣的集合运算，如并集、交集、差集

精确算法和贪婪算法：
![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g7mdykw55jj30uo0eq44c.jpg)

# NP 完全问题
实例：旅行商需要前往5个不同的城市，找出前往5个城市的最短路径，为此，必须计算每条可能的路径

从城市数少的情况着手。
- 假设只涉及**两个城市**，可供选择的路线有两条(两条路可能不同，涉及单行道)

- **三个城市**，可能的线路有$3*2*1=6$条
- **四个城市**，可能的线路有$4*3*2*1=24$条

这种被称为**阶乘函数**

> 旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。。这两个问题都属于 NP 完全问题

## 近似求解
对于旅行商问题，什么样的近似算法：随便选择出发城市，然后每次选择要去的下一个城市时，都选择还没去的**最近的**城市。

> NP 完全问题的简单定义是，以难解著称的问题，如**旅行商问题**和**集合覆盖问题**。

## 如何识别 NP 完全问题
- 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变的非常慢
- 涉及“所以组合”的问题通常是NP完全问题
- 不能将问题分成小问题，必须考虑各种可能的情况
- 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决
- 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题
- 如果问题可转换为集合覆盖问题或旅行商问题

# 小结
- 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解
- 对于NP完全问题，还没有找到快速解决方案
- 面临NP完全问题时，最佳的做法是使用近似算法
- 贪婪算法易于实现、运行速度快，是不错的近似算法
