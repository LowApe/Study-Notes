# 广度优先搜索
本章内容
- 学习使用新的数据结构**图**来创建网络模型
- 学习广度优先搜索
- 学习有向图和无向图
- 学习拓扑排序

# 图简介
1. 使用图来创建问题模型
2. 使用广度优先搜索解决问题

# 图是什么
图由**节点**和**边**组成

# 广度优先搜索
> 广度优先搜索：又称宽度优先搜索，简称 BFS。BFS是用于图的查找算法(要求能用图表示出问题的相关性)

BFS 能用来解决两类问题：
- 第一类问题：从节点A出发，有前往节点B的路径吗？
- 第二类问题：从节点A出发，前往节点B的哪条路径最短？

> 在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系

## 队列
队列的工作原理与现实生活中的队列完全相同
- FIFO(First Input First Output)先进先出
- LIFO(Last Input First Output)后进后出

# 实现图

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g7k7jssk6ij312s0toqfp.jpg)

```python
# 通过散列表来存储图信息，因为散列表是无序，因此添加顺序无关紧要
graph={}
graph["you"] = ["a","b","c"]
graph["b"] = ["an","pe"]
graph["a"] = ["pe"]
graph["c"] = ["th","jo"]
graph["an"] = []
graph["pe"] = []
graph["th"] = []
graph["jo"] = []
```
> an、pe、th、jo 没有邻居，所以是单向的

# 实现算法
![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g7k5cm0vkwj30s80yotjc.jpg)

更新队列时，我们使用术语"入队"和"出队"

首先，创建一个队列。在python中，可使用函数 deque 来创建一个双端队列


```python
from collections import deque
search_queue = deque () # 创建一个队列
search_queue += graph["you"] # 添加你以及朋友

while search_queue: #只要队列不为空
    person = search_queue.popleft()
    if person_is_seller(persion):
        print person + " is a mango seller"
        return True
    else:
        search_queue +=graph[person]#如果不是销售商将这个人的朋友都加入搜索队列
    return False

def person_is_seller(name):
    return name[-1] == 'm'
```

> 如果其中一个人同时是两个人的好友，将会导致无限循环，可以使用一个列表来记录检查过的人

广度优先搜索最终代码
```python
from collections import deque
# 通过散列来存储图信息
graph={}
graph["you"] = ["a","b","c"]
graph["b"] = ["an","pe"]
graph["a"] = ["pe"]
graph["c"] = ["th","jo","m"]
graph["an"] = []
graph["pe"] = []
graph["th"] = []
graph["jo"] = []
def search(name):
    search_queue = deque()
    search_queue +=graph[name]
    searched = []
    while search_queue:
        person = search_queue.popleft()
        if person not in searched:
            if person_is_seller(person):
                print(person + " is a mango seller")
                return True
            else:
                search_queue +=graph[person]#如果不是销售商将这个人的朋友都加入搜索队列
        return False


def person_is_seller(name):
    return name[-1] == 'm'

print(search("you"))

```

运行时间
如果检查整个人际关系网，也就是要将每条边都进过，因此运行时间至少为O(边数)

将一个人添加到队列需要的时间是固定的，即为O(1),因此对每个人都这样做需要的总时间为 O(人数)。所以，广度优先搜索的运行时间为O(人数+边数)，通常写作O(V+E),其中 V为顶点数，E为边数

> 拓扑排序：如果任务A依赖于任务B，在列表中任务A就必须在任务B后面

# 小结

- 广度优先搜素指出是否从A到B的路径
- 如果有，广度优先搜索将会找出最短路径
- 面临类似于寻找最短路径的问题时，可尝试使用图来创建模型，再使用广度优先搜索来解决问题
- 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列
- 对于检查过的人，务必不要再去检查，否则可能导致无限循环
