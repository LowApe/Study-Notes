# 接下来做如何做

本章内容

- 介绍10种算法，以及它们很有用的原因
- 如何根据兴趣选择接下来要阅读的内容

## 树

> 二叉查找树，对于其中的每个节点，左子节点的值都比它小，而右子节点的值都比它大。在二叉查找树中查找节点时，平均运行时间为 O(log n)，但在最糟糕的情况下所需时间为 O(n)；

而在有序数组中查找时，即便是在最糟糕情况下也只有O(log n),因此你可能认为有序数组比二叉查找树更佳，然而，二叉查找树的插入和删除操作的速度要快得多。

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8aa6lxjc5j30tc0f679v.jpg)

二叉查找树也存在一些缺点，不能随机访问，在二叉查找树处于平衡状态时，平均访问时间也为 O(log n)。假设二叉查找树像下面这样处于不平衡状态。

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8aaad28a9j30l40omwi4.jpg)

这棵树是向右倾斜的，因此性能不佳。也有处于平衡状态的特殊二叉查找树，如**红黑树**

**B树**是一种特殊的二叉树，数据库常用它来存储数据。

如果你对数据库或高级数据结构感兴趣，可以研究：**B树，红黑树，堆，伸展树**



## 反向索引

这里非常简单地说说搜索发动机的工作原理。假设你有三个网页，内容如下

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8aawo19zvj30vi0ben1y.jpg)

根据这些内容创建一个散列表

| 内容 | 表   |
| ---- | ---- |
| HI   | A，B |
| THRE | A，C |
| ADIT | B    |
| WE   | C    |
| GO   | C    |

如果有人检索 hi，搜索就会发现页面 A 和 B 包含 hi，因此讲这些页面作为搜索结果呈现给用户。这种数据结构被称为反向索引（内容为 key，存放的页数为 value），常用于创建搜索

## 傅里叶变换

> 傅里叶变换做一个绝佳的比喻：给它一杯冰沙，它能告诉你其中包含哪些成分，换而言之，给定一首歌曲，傅里叶变换能够将其中的各种频率分离出来

傅里叶变换非常适合用于**处理信号**，可使用它来压缩音乐。傅里叶变换能够准确地指出各个音符对整个歌曲的贡献，让你能够将不重要的音符删除。这就是 MP3格式的工作原理。

- JPG也是一种压缩格式，采用相同的工作原理。
- 傅里叶变换还被用来**地震预测和DNA分析**
- 可创建类似于音乐识别软件

## 并行算法

如果你要提高算法的速度，可等上几个月。为了提高算法的速度，你需要让它们能够在多个内核中**并行地执行**

并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点是确定的，那就是速度的提升并非线形的，因此即便你的笔记本电脑装备了两个内核，算法的速度也不可能提高一倍，其中的原因有两个

- 并行性管理开销
- 负载均衡

## MapReduce

有一种特殊的并行算法正越来越流行，它就是**分布式算法**，在并行算法只需两到四个内核时，完全可以在笔记本电脑上运行它，但如果需要数百个内核呢？在这种情况下，可让算法在多台计算机上运行。 MapReduce 是一种流行的分布式算法，你可以通过流行的开源工具**Apache Hadoop**来使用它

### 分布式算法为何很有用

假设你有包含十亿乃至很大的数据库表，需要对其执行复杂的 SQL 查询。在这种情况下，你不能使用 MySQL，因为数据库的行数超过数十亿后，它处理起来将很吃力。相反，你需要通过 HAdoop 来使用 MapReduce

分布式算法非常适合用于在短时间内完成海量工作，其中的 MapReduce 基于两个简单的理念：**映射(Map)函数和归并(reduce)函数**

### 映射函数

> 它接受一个数组，并对其中的每个元素执行同样的处理。例如，下面的映射函数将数组的每个元素翻倍

```python
arr1 = [1,2,3,4,5]
arr2 = map(lambda x:2 * x,arr1)
[2,4,6,8,10]
```

如果需要的时间非常多呢，如果处理 1000个这样的数组，并且每个元素进行处理相对复杂的操作，则需要几个小时，当我们有 100 台计算机，而 map 能够自动将工作分配给这些计算机去完成就好了。这样同时处理 10个操作，速度就快的多

## 归并函数

> 其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组

而归并是将一个数组转换为一个元素

```python
arr1 = [1,2,3,4,5]
reduce(lambda x,y: x+y,arr1)
15
```

## 布隆过滤器和 HyperLogLog

假设你管理着网站 Reddit 每当有人发布连接时，你都要检查它以前是否发布过，因为之前未发布过的故事更有价值

假设你在 Google 负责搜索页面，但只想搜集新出现的网页，因此需要判断网页是否搜集过。

这些都是用一种类型的问题，**涉及庞大的集合**

例如：Google 可能有一个庞大的散列表，其中的键是已搜集的页面。

只是 Google 需要创建万亿个网页的索引，因此这个散列表非常大，需要占用大量的存储空间。

### 布隆过滤器

> 布隆过滤器是一种概率型数据结构，它提供的答案有可能不对，但很可能是正确的。为判断页面以前是否已搜索，可不使用散列表，而使用布隆过滤器，答案却是很可能是正确的

- 可能出现错报的情况，即 Google指出网站已搜集，但实际上并没有搜集
- 不可能出现**漏报的情况**，即如何布隆过滤器说“这个网站未搜集”，就肯定未搜集

布隆过滤器的优点在于占用的存储空间很少。使用散列表时，必须存储 Google 搜集过的所有 URL，但使用布隆过滤器。布隆过滤器非常适合用于不要求答案绝对准确的情况

### HyperLogLog

HyperLogLog 是一种类似于布隆过滤器的算法。如果 Google 要计算用户执行的不同搜索的数量，或者 Amazon 要计算当天用户游览的不同商品的数量，要回答这些问题，需要耗用大量的空间！对于 Google 来说，必须有一个日志，其中包含用户执行的不同搜索。有用户执行搜索时，Google 必须判断该搜索是否包含在日志中：如果答案是否定的，就必须将其加入到日志中。即便只记录一天的搜索，这种日志也不得不得了！

HyperLogLog 近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八分不离十，而占用的内存空间却少得多

面料海量数据且只要求答案八九不离十时，可考虑使用**概率型算法**

## SHA算法

之前的散列表，散列函数接受一个字符串，并返回一个索引号

### 比较文件

另一种散列函数是**安全散列算法(secure hash algorithm,SHA)函数**。给定一个字符串，SHA 返回其散列值

```
“hello” => 2cf24db...
```

SHA 是一个散列函数，它生成一个**散列值**--一个较短的字符串。用于创建散列表的散列函数根据字符串**生成数组索引**，而 SHA 根据字符串生成**另一个字符串**。

对于每个不同的字符串，SHA 生成的散列值都不同

你可使用 SHA 来判断两个文件是否相同，这在比较超大型文件时很有用。假设你有一个 4GB 的文件，并要检查朋友是否也有这个大型文件。为此，你不用通过电子邮件将这个文件发送给朋友，而可计算它们的SHA散列值，再对结果进行比较

### 检查密码

密码存储的是密码的散列值，网站密码检查，不必存储密码，SHA被广泛用于**计算密码的散列值**。这种散列算法是**单向的**。你可根据字符串计算出散列值

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8ahj05d4mj30pq02k3zq.jpg)

到那时你无法根据散列值推断出原始字符串

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8ahjcrctlj30me044t9s.jpg)

SHA 实际上是一系列算法：SHA-0、SHA-1、SHA-2和SHA-3。

## 局部敏感的散列算法

SHA 还有一个重要特征，那就是局部不敏感。假设一个字符串，并计算其散列值。如果你修改其中一个字符，再计算其散列值，结果将截然不同！

当使用密码的时候，这种局部不敏感的散列算法很好。但有些时候希望散列函数是局部敏感的。

- Google 使用 Simhash 来判断网页是否已搜集
- 老师可以通过使用 Simhash 来判断学生的论文是否从网上抄的

## Diffie-Hellman 密钥交换

如何对消息进行加密，以便只有收件人才能看懂呢？

最简单的方式是设计一种加密算法，如将 a 转换为 1，b 转换为 2，以此类推。这样，如果我给你发送消息“4，15，7”，你就可将其转换为 “d,o,g”。但我们必须就加密算法达成一致，这种方式才可行。

![image.png](http://ww1.sinaimg.cn/large/006rAlqhly1g8ahvpfhrjj30xe0re7ht.jpg)

Diffie-Hellman 算法解决了如下两个问题

- 双方无需知道加密算法
- 要破解加密消息比登天还难

Diffie-Hellman 使用两个密钥：公钥和私钥。有人想你发送消息时，他使用公钥对其进行加密。加密后的消息只有使用私钥才能解密。只要只有你知道私钥，就只有你才能解密消息

