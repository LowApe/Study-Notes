# web安全机制
## 基础安全知识
> XSS(Cross Site Script 跨站脚本攻击)<br>
SQL(Structured Query Language )注入<br>
CSRF(Cross-site Request Forgery 跨站请求伪造)

### XSS:
由带有页面可解析内容数据未经处理直接插入到页面上解析导致的。
根据攻击脚本的引入位置分为三类。
> 存储型XSS<br>
这种攻击脚本常常由前端提交的数据未经处理直接存放到数据库，然后从数据库中读取出来后又直接插入到页面中导致的。

> 反射型XSS<br>
这种攻击是在页面 URL 参数中注入了可解析内容的数据导致，如果直接获取 URL 中不合法的并插入页面中则可能出现页面上的 XSS 攻击。

> MXSS(DOM XSS)<br>
这种攻击是在渲染 DOM 属性时将攻击脚本插入 DOM 属性中被解析而导致的。

XSS 主要防范方法是验证输入到页面上所以内容来源数据是否安全，如果可能含有脚本标签等内容测需要进行必要的转义。

**实例**
```JS
// HTML 字 符 转 译 编 码
function htmlEncode( str)
{
    let s = '';
    if (str.length = = 0) return '';
    s = str.replace(/&/ g, '& amp;');
    s = s.replace(/ </ g, '& lt;');
    s = s.replace(/ >/ g, '& gt;');
    s = s.replace(/ /g, '& nbsp;');
    s = s.replace(/\'/ g, '&# 39;');
    s = s.replace(/\"/ g, '& quot;');
    s = s.replace(/\ n/ g, '< br >');
    return s;
 }

```

```js
// HTML 字 符 转 译 解 码
function htmlDecode( str)
{
    let s = '';
    if (str.length = = 0) return '';
    s = str.replace(/& amp;/ g, '&');
    s = s.replace(/& lt;/ g, '<');
    s = s.replace(/& gt;/ g, '>');
    s = s.replace(/& nbsp;/ g, ' ');
    s = s.replace(/&# 39;/ g, '\'');
    s = s.replace(/& quot;/ g, '\"');
    s = s.replace(/ < br >/ g, '\ n');
    return s;
}

```
    这样，script 等内容的标签符号就会直接在页面中显示，而不是被游览器解析成 script 的 DOM 节点来执行。

### SQL 注入攻击
 SQL 注入攻击主要是因为页面提交数据到服务端后，在服务端未进行数据验证就将数据直接拼接到 SQL 语句中执行，因此产生执行与预期不同的现象。主要防范措施是对前端页面提交的数据内容进行严格的检查校验

 ### CSRF
CSRF 是指非源站点按照站点的数据请求格式提交非法数据给源站点服务器的一种攻击方式。通常比较安全的是通过页面 Token (令牌)提交验证的方式验证请求是否为源站点页面提交的，来阻止跨站伪请求的发生。

![](http://ww1.sinaimg.cn/large/006rAlqhly1fss2iplot3j30ax06saa8.jpg)
CSRF 攻击原理

![](http://ww1.sinaimg.cn/large/006rAlqhly1fss2lsf7ufj30ax07ogls.jpg)
CSRF 预防机制

```js
// 生 成 随 机 的 csrf 验 证 Token， 并 返 回 给 前 端 页 面
this.session.csrf = md5( Math.random( 0, 1). toString()). slice( 5, 15);
this.body = yield render(' user/ login', { csrf: ctx.session.csrf });
 // 提 交 时 验 证 Token 是 否 与 源 站 的 Token 相 同
let csrf = this.request.body[' csrf'];
if (csrf != = this.session.csrf)
{
    res = { code: 403, msg: '不 明 网 站 来 源 提 交' }
} else
{
    // 正 常 提 交 后 的 处 理 逻 辑
}


```

> 目前解决 CSRF 的最佳方式就是通过加密计算的 Token 验证，而 Token 除了通过 session 也可以使用 HTTP 请求头中 Authorization 的特定认证字段来传递。 当然并不是说使用了 Token，网站调用服务就安全了，单纯的 Token 验证防止 CSRF 的方法理论上也是可以被破解的，列如可以通过域名伪造和拉取源站实时 Token 信息的方式来进行提交。另外，任何所谓的安全都是相对的，只是说理论的破解时间变长了，而不容易被攻击。很多时候要使用多种方法结合的方式来一起增加网站的安全性，可以结合验证码等数段大大减少盗刷网站用户信息的频率等，进一步增强网站内容安全性。
