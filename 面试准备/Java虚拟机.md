

# JVM

JVM的组成：

- 字节码指令集
- 寄存器
- 栈
- 垃圾回收
- 堆
- 存储方法域



# 操作过程

Java 源文件(.java)，通过编译器(javac)，能够生产相应的**字节码**(.class )文件.字节码文件又通过 Java 虚拟机中的解析器，编译成特定机器上的机器码

1. Java源文件->编译器->字节码文件
2. 字节码文件->JVM(多种平台解释器)->机器码



在 HotSpot 里面，将字节码翻译成机器码，有两种形式：

- 解释执行，即**逐条**翻译成机器码并执行
- 即时编译，即将一个**方法**中**包含**的**所有**字节码翻译成机器码后再执行

前者无需等待编译，而后者的优势在于实际运行速度更快。(我能理解idea 即使编译器用的这块嘛) **HotSpot 默认采用混合模式，先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。**



为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器:C1、C2 和 Graal. Graal 是 Java 10 正式引入的实验性即时编译器。

- **C1: ** Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。
- **C2：**面向的是对**峰值性能**有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。

从 Java 7 开始，HotSpot 默认采用分层编译的方式：**热点方法**首先会被 C1 编译，而后热点方法中的**热点**会进一步被 C2 编译。

HotSpot 的即时编译是放在**额外的编译线程**中进行的。HotSpot 会根据 **CPU 的数量**设(cpu的数量还是核心的数量？)置编译线程的数目，并且按 1:2 的比例配置给 C1 及 C2 编译器。

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gqz57k097gj614u0740uv02.jpg)

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gqz5ghzddwj611c04qaav02.jpg)

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gqz6qsnfjsj614y0cw0v702.jpg)

# 为什么JVM能跨平台？

因为JVM内置多种平台解析器，将Java字节码文件解析成对应平台机器码。

# 一个程序的生命周期

当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个**虚拟机实例**。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。



从虚拟机视角来看，执行 Java 代码首先需要将它编译而成的 class 文件记载到 Java 虚拟机中。

- 加载后的 Java 类会被存放于方法区(Method Area) 中。实际运行时，虚拟机会执行方法区内的代码
- Java 虚拟机同样也在内存中划分**堆和栈**来存储运行时数据。不过Java虚拟机将栈细分为
	- 面向 Java 方法的 **Java 方法栈**
	- 面向本地方法(用 C++ 写的native方法)的**本地方法栈**
	- 以及存放各个线程执行位置的 PC 寄存器

在运行过程中，每当调用进入一个Java方法，Java虚拟机会在当前，

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gqyb8ur1vuj60js0h2jtg02.jpg)

在运行过程中，每当需要**调用**进入一个Java方法，虚拟机会在当前线程的 **Java 方法栈中生成一个栈帧**，用以存放局部变量以及字节码的操作数(程序计数器)。这个栈帧的大小是提前计算好的(根据方法涉及到类型大小？)，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧。

# 线程



这里所说的线程指程序执行过程中的一个线程实体。



# JVM 内存区域

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gqz7abge5qj611a0ns7tp02.jpg)

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- Java 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)



### 程序计数器

当前线程所执行的字节码的行号指示器。

- 通过改变这个计数器的值来选取下一条需要执行的字节码指令,**分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。**
- 多线程的情况下，用于记录当前线程执行的位置，用于线程切换指导上次运行到哪

唯一一个无OOM的区域

### Java 虚拟机栈

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gr1ehwlhg4j609i0dgt9p02.jpg)

生命周期与线程相同，描述的是 **Java 方法执行**的内存模型，每次方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储**局部变量表(基本类型，引用)**、操作数栈、动态链接、方法出口信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

### 本地方法栈

虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到 Native 方法方法服务

### 方法区

用于存储已被虚拟机加载的**类信息、常量、静态变量**、即时编译器编译后的代码等元数据。

### 堆

创建的对象和数组都保存在 Java 堆内存中，也就是垃圾收集器进行垃圾收集的重要内存区域。

从 JDK 1.7 开始已经默认开启**逃逸分析**，如果某些方法中的对象引用**没有被返回或者未被外面使用**（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**

由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

JDK 7 版本之前，堆内存被通常被分为下面三部分：

1. 新生代内存
2. 老生代
3. 永生代

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gr1f3qh3iqj60oq0b8dlp02.jpg)

JDK8版本之后方法区(HotSpot的永久代)被彻底移出，区而代之是元空间，元空间使用的是直接内存。

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gr1f9rewv1j60sc0cu49002.jpg)

大部分情况，对象都会首先在 Eden 区域分配，在一次**新生代垃圾回收**后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁(15次回收)），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

> HotSpot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survior 区的一半时，取这个年龄和  MaxTenuringThreshold 中更小的一个值，作为新的的晋升年龄阀值。

- 新生代 （1/3） 堆空间，老年代(2/3)堆空间

> 分代收集MinorGC的过程：
>
> - 把 Eden 和  Survivor From区域中存活的对象复制到  Survivor To ，同时把这些对象的年龄 + 1
> - 然后清空 Eden、Survivor From 中的对象
> - Survivor To 和 Survivor From 互换，原 Survivor To 成为下一次 GC 时复制区 
>
> 分代收集MajorGC的过程：
>
> - 在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋升老年代。MajorGC 采用**标记清除算法**：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 会产生内存碎片，为了减少内存损耗，一般需要进行合并方便下次直接分配

### 运行时常量池

jdk 1.7 之前

### 直接内存



### Java 8 元数据

在 Java8 ，永久代已经被移除，被元空间的区域所取代。元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**

### 常见参数

```java
// jdk1.8 之前
-XX:PermSize=N //方法区(永久代)初始化大小
-XX:MaxPermSize=N //方法区(永久代)最大大小，超过这个值将会抛出OOM

    
// jdk1.8
-XX:MetaspaceSize=N 
-XX:MaxMetaspaceSize=N   
```

与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，**虚拟机会耗尽所有可用的系统内存**



## 垃圾回收与算法

### 确定垃圾回收：

- 引用计数法
- 可达性分析：不可达对象变为可回收对象至少要经过两次标记过程。两次标记仍为可回收对象，则将面临回收。

### 回收算法：

标记清除算法：

- 先标注再清除

复制算法：

- 按内存容量将内存划分为等大小的两块。每次只使用其中一块。
- 当一块内存满后将尚存活的对象复制到另一块，把这一块内存清理

标记整理算法：

- 结合以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，**标记后不是清理对象，而是将存活对象移向内存的一端**。然后清除段边外的对象。

分区收集算法：

- 分区算法则将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。这样做的好处是控制一次回收多少个小区间。



> 新生代主要使用复制和标记-清除算法
>
> 老年代每次回收少量对象。因而采用标记-整理算法

jdk 1.6 中 Sun HotSpot 虚拟机的垃圾收集器：

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gr1lkpvdj6j60ss0kgand02.jpg)

- Serial:单线程，复制算法，暂停所有工作线程
- ParNew：Serial多线程版本，复制算法，暂停所有工作线程。
- Parallel Scavenge:可控制的吞吐量，自适应调节
- Serial Old: 单线程标记整理
- Parallel Old:提供吞吐量优先的垃圾收集器

新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图：

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gr1lvm26ntj60xi09mdpt02.jpg)

新生代 Parallel Scavenge 和年老代 Parallel Old 收集器

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gr1m5vx8exj60xq0cwqgq02.jpg)

- CMS 收集器：标记清除算法
	- 初始标记：标记 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程
	- 并发标记：进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程
	- 重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。
	- 并发清除：清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gr1mblknksj60ww09sk6702.jpg)

G1 收集器：

- 基于标记-整理算法，不产生内存碎片
- 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收





# 虚拟机对象

了解一下 HotSpot 虚拟机再 Java 堆中对象分配、布局和访问的全过程。

## 对象的创建

1. 类加载坚持
2. 分配内存
3. 初始化零值
4. 设置对象头

### 类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程

### 分配内存

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。分配方式：

- 指针碰撞
- 空闲列表

选择那种分配方式，根据 Java 堆是否规整决定，而 Java 堆是否规整有根据采用的GC收集器是否带有压缩整理功能决定

内存分配并发问题：

- CAS+失败重试：
- TLAB：为

### 初始化零值



### 设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。



### 执行的 init 方法

执行 new 执行之后会接着执行 `<init>`方法，把对象按照程序员的意愿进行初始化



## 对象的内存布局

对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。

## 对象的访问定位

创建对象就是为了使用对象，我们的 Java 程序通过栈上的 refernece 数据来操作堆上的具体对象。主流的访问方式有

1. **句柄：**Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了**对象实例数据**与类型数据各自的具体地址信息

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gr1n4amckuj615m0js49102.jpg)

2. **直接指针**：如果使用直接指针访问，那 Java 堆对象的布局就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址

![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gr1n3qh7qaj617k0js7du02.jpg)

> - **使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。**
>
> - **使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**





# String 类和常量池



![image.png](http://ww1.sinaimg.cn/large/005HA6kBgy1gr1ninz5chj60ci06xgnq02.jpg)



```java
String s1 = "计算机";
String s2 = s1.intern();
String s3 = "计算机";
System.out.println(s2);//计算机
System.out.println(s1 == s2);//true
System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象
```

- 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。

# 参考链接

- [JavaGuide](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F?id=java-%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f%e8%af%a6%e8%a7%a3)
- Java核心知识点手册
- 极客时间-深入拆解Java虚拟机









