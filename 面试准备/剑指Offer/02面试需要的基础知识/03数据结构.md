# 数据结构

数据结构一直是技术面试的重点，大多数面试题都是围绕着**数组、字符串、链表、树、栈及队列**这几种常见的数据结构展开的，因此每一个应聘者都要掌握这几种数据结构

| 数据结构     | 描述                                                         |
| :----------- | ------------------------------------------------------------ |
| 数组和字符串 | 它们用连续内存分别存储数字和字符串                           |
| 链表和树     | 面试中出现频率最高的的数据结构。<br />由于操作链表和树需要操作大量的指针 |
| 栈           | 栈是一个与递归紧密相关的数据结构                             |
| 队列         | 与广度优先变量算法紧密相关                                   |

## 数组

数组占据一块连续的内存并按照顺序存储数据(O(1)读取/写入)<br/>创建数组时，我们需要首先指定数组的容量大小，然后根据容量大小分配内存<br/>即使我们只在数组存储一个数字，也需要为所有的数据预先分配内存。因此数组的空间效率不是很好，经常会有空闲的区域没有利用

> 由于数组的时间效率很高，我们根据数组时间效率高的优点，用数组来实现简单的**哈希表**：把数组下标设为哈希表的键值(Key)，而把数组中的每个数字设为哈希表的值(Value),这样每一个下标及数组中该下标对应的数字就做成了一个“键值-值”的配对。这样的哈希表，我们就可以在 O(1)时间内实现查找

### 面试题3:数组中重复的数字

> 题目一：找出数组中重复的数字
>
> 在一个长度为 n 的数组里的所有数字都在 0～n-1 范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 {2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3

1. 先把数组排序，从头到尾扫描排序后的数组
2. 利用哈希表来解决这个问题。从头到尾扫描每一个数字，每扫描到一个数字的时候，都可以用O(1)的时间来判断哈希表里是否已经包含该数字。如果哈希表没有该数字，就将这个数字加入哈希表。如果哈希表里已经存在该数字，就找到一个重复的数字。这个算法的时间复杂度是O(n),但它提高时间效率是以一个大小O(n)的哈希表为代价的
3. 注意数组中的数字都在 0～n-1范围，如果没有重复的，那数组下标 i 的位置就是数字 i。
    - 当扫描到下标为 i 的数值时，首先比较这个数字 m 是不是等于 i 如果是，则接着扫描下一个。如果不是，拿 m 位置数值进行比较，如果相等则找到一个**重复的数字**，如果不相等，就把当前 i 位置的数值与 m 位置的数值**交换**。接下来重复这个比较、交换的过程

```c++
bool duplicate(int numbers[],int length,int* duplication) //判断是否有重复
{
	if(numbers == nullptr || length <= 0)
    {
        return false;
    }
    
    for(int i=0;i<length;++i)
    {
        if(numbers[i]<0 || numbers[i] > length -1) //数值的合法边界
      		return false
    }
    
    for(int i=0;i < length;++i)
    {
        while(numbers[i] !=i)
        {
            if(numbers[i] == numbers[numbers[i]])
            {
                *duplication = numbers[i];
                return true;
            }
            //如果不相等则交换
            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }
    return false;
}
```

> 题目二：不修改数组找出重复的数字。<br />在一个长度为 n+1 的数组里的所有数字都在 1～n 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7},那么对应的输出是重复的数字2或3

1. 由于题目要求不能修改数组，我们创建一个长度为 n+1 的辅助数组。然后逐一把原数组的每一个数字复制到辅助数组。如果原数组中被复制的数字是 m ,则把它复制到辅助数组中下标为 m 的位置。这样很容易发现哪个数字是重复的。由于创建数组，此方案需要O(n)的辅助空间
2. 我们把从 1~n 的数字从中间的数字 m 分为两个部分，前面一半为 1~m，后面一半为 m+1~n。如果1~m 的数字的次数超过 m ，那么这一半的区间里一定包含重复的数字。这个过程和二分查找算法很类似，只是多了一个统计区间里数字的数目

```c++
int getDuplication(const int* numbers,int length){
    if(numbers == nullptr || length <= 0) //判断空
        return -1;
    int start = 1;
    int end = length -1;
    while(end>=start)
    {
        int middle = ((end - start)>>1)+start;
        int count = countRange(numbers,length,start,middle); //查询区间范围内在整个数组出现的次数
        if(end == start) //如果范围缩小到一个数
        {
            if(count > 1) 
                return start;
            else
                break;
        }
        if(count > (middle-start + 1))
            end = middle;
        else
            start = middle + 1;
    }
    return -1;
}

int countRange(const int* numbers,int length,int start,int end)
{
    if(numbers == nullptr)
        return 0;
    int count = 0;
    for(int i=0;i<length;i++)
        if(numbers[i] >= start && numbers[i] <= end)
            ++count;
    return count;
}
```

这些代码按照二分查找的思路，如果输入长度为 n 的数组，那么函数 countRange 将被调用O(logn)次，每次需要 O(n) 的时间，因此总的时间复杂度是 O(nlogn)，空间复杂度 O(1)。这种算法相当于以时间换空间

> ⚠️注意：这种算法不能保证找出所有重复的数字。例如，该算法不能找出数组{2,3,5,4,3,2,6,7}中重复的数字2.因为在1～2范围里有1和2两个数字，这个范围的数字也出现了两次

### 面试题4:二维数组中的查找

