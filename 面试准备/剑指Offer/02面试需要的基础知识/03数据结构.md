# 数据结构

数据结构一直是技术面试的重点，大多数面试题都是围绕着**数组、字符串、链表、树、栈及队列**这几种常见的数据结构展开的，因此每一个应聘者都要掌握这几种数据结构

| 数据结构     | 描述                                                         |
| :----------- | ------------------------------------------------------------ |
| 数组和字符串 | 它们用连续内存分别存储数字和字符串                           |
| 链表和树     | 面试中出现频率最高的的数据结构。<br />由于操作链表和树需要操作大量的指针 |
| 栈           | 栈是一个与递归紧密相关的数据结构                             |
| 队列         | 与广度优先变量算法紧密相关                                   |

## 数组

数组占据一块连续的内存并按照顺序存储数据(O(1)读取/写入)<br/>创建数组时，我们需要首先指定数组的容量大小，然后根据容量大小分配内存<br/>即使我们只在数组存储一个数字，也需要为所有的数据预先分配内存。因此数组的空间效率不是很好，经常会有空闲的区域没有利用

> 由于数组的时间效率很高，我们根据数组时间效率高的优点，用数组来实现简单的**哈希表**：把数组下标设为哈希表的键值(Key)，而把数组中的每个数字设为哈希表的值(Value),这样每一个下标及数组中该下标对应的数字就做成了一个“键值-值”的配对。这样的哈希表，我们就可以在 O(1)时间内实现查找

### 面试题3:数组中重复的数字

> 题目一：找出数组中重复的数字
>
> 在一个长度为 n 的数组里的所有数字都在 0～n-1 范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 {2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3

1. 先把数组排序，从头到尾扫描排序后的数组
2. 利用哈希表来解决这个问题。从头到尾扫描每一个数字，每扫描到一个数字的时候，都可以用O(1)的时间来判断哈希表里是否已经包含该数字。如果哈希表没有该数字，就将这个数字加入哈希表。如果哈希表里已经存在该数字，就找到一个重复的数字。这个算法的时间复杂度是O(n),但它提高时间效率是以一个大小O(n)的哈希表为代价的
3. 注意数组中的数字都在 0～n-1范围，如果没有重复的，那数组下标 i 的位置就是数字 i。
    - 当扫描到下标为 i 的数值时，首先比较这个数字 m 是不是等于 i 如果是，则接着扫描下一个。如果不是，拿 m 位置数值进行比较，如果相等则找到一个**重复的数字**，如果不相等，就把当前 i 位置的数值与 m 位置的数值**交换**。接下来重复这个比较、交换的过程

```c++
bool duplicate(int numbers[],int length,int* duplication) //判断是否有重复
{
	if(numbers == nullptr || length <= 0)
    {
        return false;
    }
    
    for(int i=0;i<length;++i)
    {
        if(numbers[i]<0 || numbers[i] > length -1) //数值的合法边界
      		return false
    }
    
    for(int i=0;i < length;++i)
    {
        while(numbers[i] !=i)
        {
            if(numbers[i] == numbers[numbers[i]])
            {
                *duplication = numbers[i];
                return true;
            }
            //如果不相等则交换
            int temp = numbers[i];
            numbers[i] = numbers[temp];
            numbers[temp] = temp;
        }
    }
    return false;
}
```

> 题目二：不修改数组找出重复的数字。<br />在一个长度为 n+1 的数组里的所有数字都在 1～n 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7},那么对应的输出是重复的数字2或3

1. 由于题目要求不能修改数组，我们创建一个长度为 n+1 的辅助数组。然后逐一把原数组的每一个数字复制到辅助数组。如果原数组中被复制的数字是 m ,则把它复制到辅助数组中下标为 m 的位置。这样很容易发现哪个数字是重复的。由于创建数组，此方案需要O(n)的辅助空间
2. 我们把从 1~n 的数字从中间的数字 m 分为两个部分，前面一半为 1~m，后面一半为 m+1~n。如果1~m 的数字的次数超过 m ，那么这一半的区间里一定包含重复的数字。这个过程和二分查找算法很类似，只是多了一个统计区间里数字的数目

```c++
int getDuplication(const int* numbers,int length){
    if(numbers == nullptr || length <= 0) //判断空
        return -1;
    int start = 1;
    int end = length -1;
    while(end>=start)
    {
        int middle = ((end - start)>>1)+start;
        int count = countRange(numbers,length,start,middle); //查询区间范围内在整个数组出现的次数
        if(end == start) //如果范围缩小到一个数
        {
            if(count > 1) 
                return start;
            else
                break;
        }
        if(count > (middle-start + 1))
            end = middle;
        else
            start = middle + 1;
    }
    return -1;
}

int countRange(const int* numbers,int length,int start,int end)
{
    if(numbers == nullptr)
        return 0;
    int count = 0;
    for(int i=0;i<length;i++)
        if(numbers[i] >= start && numbers[i] <= end)
            ++count;
    return count;
}
```

这些代码按照二分查找的思路，如果输入长度为 n 的数组，那么函数 countRange 将被调用O(logn)次，每次需要 O(n) 的时间，因此总的时间复杂度是 O(nlogn)，空间复杂度 O(1)。这种算法相当于以时间换空间

> ⚠️注意：这种算法不能保证找出所有重复的数字。例如，该算法不能找出数组{2,3,5,4,3,2,6,7}中重复的数字2.因为在1～2范围里有1和2两个数字，这个范围的数字也出现了两次

### 面试题4:二维数组中的查找

> 题目：在一个二维数组中，每一行都按照从左到右递增的**顺序排序**，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

例如下面的二维数组就是每行、每列都递增排序。如果在这个数组中查找数字7，则返回true；如果查找数字5，由于数组不含有该数字，则返回false

```
1	2	8	9
2	4	9	12
4	7	10	13
6	8	11	15
```

正常分为三步

1. 当数组中选取的数字刚好和要查找的数字相等时，就结束查找过程
2. 如果选取的数字小于要查找的数字，那么根据数组排序的规则，要查找的数字应该在当前选取位置的右边或者下边
3. 如果选取的数字大于要查找的数字，那么根据数组排序的规则，要查找的数字应该在当前选取位置的左边或者上边

但是要查找的数字相对于选取的位置可能存在两个**区域重叠**

但我们需要解决一个复杂问题的问题时，一个很有有效的办法就是从一个具体问题入手，通过简单分析简单具体的例子，试图寻找普遍的规律。针对这个问题，我们不妨也从一个具体的例子入手，试图寻找普遍的规律。如果我们从数组中选取一个数字来和要查找的数字比较，就会导致下一次要查找的是两个相互重叠的区域。如果我们从数组的一个**角上选取数字**是否会变的简单？

如果我们要查找的是 7，从上面的题目为实例，从右上角开始，去跟9比较，发现7比9小，因为9是当前列最小的，则可以删除当前列，然后继续从删除后的右上角比较，又删除了8这列，然后继续，2<7,2这一行又是最大的数字，则删除当前行，接着比较右上角4，删除当前行，接着比较7，刚好是查找的值。

```c++
bool Find(int* matrix,int rows,int columns,int number)
{
    bool found = false;
    if(matrix !=nullptr && rows>0 && columns >0)
    {
        int row = 0;
        int column = columns - 1;
        while(row<rows&&column>0){
            if(matrix[row*columns+column]==number){
                found = true;
                return found;
            }
           	else if(matrix[row*columns + column]>number){
                --cloumn;
            }else
                ++row;
        }
    }
    return found;
}
```

## 字符串

字符串是由若干字符组成的序列。由于字符串在编程使用的频率非常高，为了优化，很多语言都对字符串做了特殊的规定。下面分别讨论C/C++字符串的特性

C/C++中每个字符串都以字符`\0`作为结尾，这样就很方便查找字符串的最后尾部。但是字符串中都有一个额外的开销，稍不留神就会造成字符串的越界。

### 面试题5：替换空格

> 题目：请实现一个函数，把字符串中的每个空格替换成`%20`.例如，输入“We are happy” ，则输出“We%20are%20happy”

在网络编程中，如果**URL参数**中含有**特殊字符**,如空格、`#`等，则可能导致服务器端无法获得正确的参数值。我们需要将这些特殊符号转换成服务器可以识别的字符。**转换规则**是在`%`后面跟上ASCII码的两位十六进制的表示。比如空格的ASCII码是32，即十六进制的0x20，因此空格被替换成`%20`.在比如'#'的ASCII码为35，即十六进制的 0x23,它在URL中被替换成为`%23`

> 原来的空格字符，替换了之后变成了`%`、`2`、`0`,因此字符串会变长。如果是**原来的字符串**上进行替换，就有可能覆盖修改在该字符串后面的内存。如果是**创建新的字符串**并在新的字符串上进行替换,那么我们自己分配足够多的内存。这两种问题应该向面试官询问清楚

#### 时间复杂度为O(n^2),不足以拿到Offer

最直观的做法是从头到尾扫描字符串，每次碰到空格字符的时候进行替换，由于是把1个字符替换成3个字符，我们必须要把空格后面所有的字符都后移2字节，否则就有两个字符被覆盖了。但是假设字符串的长度是 n。对于每个空格字符串，需要移动O(n)个字符，因此对于含有O(n)个空格字符的字符串而言，总的时间效率是O(n^2)

#### 时间复杂度为O(n),搞定Offer

如果要追求跟高的效率，我们可以先遍历一次字符串，这样就能统计出字符串中空格的总数，并可以由此计算出替换之后的字符串的总长度。每替换一个空格，长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘空格数的长度。我们从字符串的后面开始复制和替换。

```c++
/*length 为字符数组的总容量*/
void ReplaceBlank(char string[],int length)
{
    if(string == nullptr || length<=0){
        return;
    }
    int originalLength = 0;
    int numberOfBlank = 0;
    int i=0;
    while(string[i]!='\0'){//从头遍历一边
        ++originalLength;
        if(string[i]==' '){//计算空格数
            ++numberOfBlank;
        }
        ++i;
    }
    
    int newLength =originalLength + numberOfBlank * 2; //需要添加多余字符后的数组长度
    if(newLength>length)
        return;
    
    int indexOfOriginal = originalLength;//原长度末尾
    int indexOfNew = newLength;//新长度末尾
    while(indexOfOriginal>=0 && indexOfNew > indexOfOriginal){
        if(string[indexOfOriginal]==' '){
            string[indexOfNew--] = '0';
            string[indexOfNew--] = '2';
            string[indexOfNew--] = '%';
        }else{
            string[indexOfNew--] = string[indexOfOriginal];
        }
        --indexOfOriginal;
    }
}
```

> ⚠️注意：在合并两个数组(包括字符串)时，如果从前往后复制每个数字(或字符)则需要**重复移动数字(或字符)**多次，那么我们可以考虑**从后往前**复制，这样就能减少移动的次数，从而提高效率

